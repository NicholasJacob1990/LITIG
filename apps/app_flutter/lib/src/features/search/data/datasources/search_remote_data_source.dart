import 'package:dio/dio.dart';
import 'package:meu_app/src/core/error/exceptions.dart';
import 'package:meu_app/src/features/search/domain/entities/search_params.dart';
import 'package:meu_app/src/core/services/api_service.dart'; // Mantido para a l√≥gica original
import 'package:meu_app/src/features/lawyers/data/models/lawyer_model.dart';
import 'package:meu_app/src/features/firms/data/models/law_firm_model.dart';

abstract class SearchRemoteDataSource {
  Future<List<dynamic>> performSearch(SearchParams params);
  Future<List<dynamic>> performSemanticFirmSearch(SearchParams params);
}

// Classe Wrapper restaurada
class SearchResultWrapper {
  final dynamic item;
  final String searchContext;
  final double searchScore;
  final String? badge;
  
  SearchResultWrapper({
    required this.item,
    required this.searchContext,
    required this.searchScore,
    this.badge,
  });
}

class SearchRemoteDataSourceImpl implements SearchRemoteDataSource {
  final Dio dio;

  SearchRemoteDataSourceImpl({required this.dio});

  @override
  Future<List<dynamic>> performSearch(SearchParams params) async {
    try {
      // üéØ BUSCA H√çBRIDA: Combina busca sem√¢ntica + consulta direta ao diret√≥rio
      
      // 1. EXECU√á√ÉO PARALELA da busca sem√¢ntica e de diret√≥rio
      final results = await Future.wait([
        _performSemanticSearch(params),
        _performDirectorySearch(params),
      ]);
      
      final semanticResults = results[0];
      final directoryResults = results[1];

      // 2. COMBINA RESULTADOS com deduplica√ß√£o e scoring
      List<SearchResultWrapper> hybridResults = _combineAndRankResults(
        semanticResults, 
        directoryResults, 
        params
      );
      
      // 3. APLICA FILTROS FINAIS e retorna os itens originais
      return _applyFinalFilters(hybridResults, params)
          .map((wrapper) => wrapper.item)
          .toList();
      
    } catch (e) {
      throw ServerException(message: 'Falha ao realizar a busca h√≠brida.');
    }
  }

  @override
  Future<List<dynamic>> performSemanticFirmSearch(SearchParams params) async {
    if (params.query == null || params.query!.trim().isEmpty) {
      return [];
    }
    
    try {
      final response = await dio.post(
        '/api/firms/semantic-search',
        data: {
          'query': params.query,
          'top_k': 15,
        },
      );
      if (response.statusCode == 200 && response.data is List) {
        return response.data;
      } else {
        throw ServerException(message: 'Erro ao buscar escrit√≥rios via busca sem√¢ntica.');
      }
    } on DioException catch (e) {
      throw ServerException(message: e.response?.data['detail'] ?? 'Erro de rede ao buscar escrit√≥rios.');
    }
  }

  /// Busca sem√¢ntica via API (usa IA para matching inteligente)
  Future<List<SearchResultWrapper>> _performSemanticSearch(SearchParams params) async {
    try {
      const caseId = 'semantic_search_case';
      
      final result = await ApiService.getMatches(
        caseId,
        preset: params.preset,
        customLatitude: params.latitude,
        customLongitude: params.longitude,
        radiusKm: params.radiusKm,
      );

      final lawyers = (result['lawyers'] as List? ?? [])
          .map((data) => LawyerModel.fromJson(data))
          .toList();
      
      final firms = (result['firms'] as List? ?? [])
          .map((data) => LawFirmModel.fromJson(data))
          .toList();

      List<SearchResultWrapper> wrappedResults = [];
      
      // Envolve advogados com metadados sem√¢nticos
      for (var lawyer in lawyers) {
        wrappedResults.add(SearchResultWrapper(
          item: lawyer,
          searchContext: 'semantic',
          searchScore: 0.8, // Score alto para busca sem√¢ntica
          badge: 'üß† Sem√¢ntico',
        ));
      }
      
      // Envolve escrit√≥rios com metadados sem√¢nticos
      for (var firm in firms) {
        wrappedResults.add(SearchResultWrapper(
          item: firm,
          searchContext: 'semantic',
          searchScore: 0.8,
          badge: 'üß† Sem√¢ntico',
        ));
      }

      return wrappedResults;
    } catch (e) {
      // Se busca sem√¢ntica falhar, retorna lista vazia
      return [];
    }
  }

  /// Busca direta no diret√≥rio (filtros espec√≠ficos + busca textual)
  Future<List<SearchResultWrapper>> _performDirectorySearch(SearchParams params) async {
    try {
      // Chama o novo endpoint de busca por diret√≥rio
      final results = await ApiService.directorySearch(params);
      
      // Envolve resultados com metadados de diret√≥rio
      List<SearchResultWrapper> wrappedResults = [];
      for (var item in results) {
        wrappedResults.add(SearchResultWrapper(
          item: item,
          searchContext: 'directory',
          searchScore: (item is LawyerModel) ? item.score : 0.7, // Usa score da API
          badge: 'üóÑÔ∏è Diret√≥rio',
        ));
      }
      
      return wrappedResults;
    } catch (e) {
      // Em caso de erro, retorna lista vazia para n√£o quebrar a busca h√≠brida
      return [];
    }
  }

  /// Combina resultados sem√¢nticos e de diret√≥rio com deduplica√ß√£o
  List<SearchResultWrapper> _combineAndRankResults(
    List<SearchResultWrapper> semanticResults,
    List<SearchResultWrapper> directoryResults,
    SearchParams params,
  ) {
    Map<String, SearchResultWrapper> combinedMap = {};
    
    // Adiciona resultados sem√¢nticos (prioridade alta)
    for (var wrapper in semanticResults) {
      String id = _getItemId(wrapper.item);
      combinedMap[id] = wrapper;
    }
    
    // Adiciona resultados de diret√≥rio (evita duplicatas)
    for (var wrapper in directoryResults) {
      String id = _getItemId(wrapper.item);
      if (!combinedMap.containsKey(id)) {
        combinedMap[id] = wrapper;
      } else {
        // Se j√° existe, marca como resultado h√≠brido e combina scores
        var existing = combinedMap[id]!;
        combinedMap[id] = SearchResultWrapper(
          item: existing.item,
          searchContext: 'hybrid',
          searchScore: (existing.searchScore + wrapper.searchScore) / 2,
          badge: '‚ö° H√≠brido',
        );
      }
    }
    
    // Converte para lista e ordena por score
    List<SearchResultWrapper> combinedResults = combinedMap.values.toList();
    combinedResults.sort((a, b) => b.searchScore.compareTo(a.searchScore));
    
    return combinedResults;
  }

  /// Aplica filtros finais baseados em query textual
  List<SearchResultWrapper> _applyFinalFilters(List<SearchResultWrapper> results, SearchParams params) {
    if (params.query == null || params.query!.isEmpty) {
      return results;
    }
    
    final query = params.query!.toLowerCase();
    return results.where((wrapper) {
      final item = wrapper.item;
      if (item is LawyerModel) {
        return item.name.toLowerCase().contains(query) ||
               item.oab.toLowerCase().contains(query);
      }
      if (item is LawFirmModel) {
        return item.name.toLowerCase().contains(query);
      }
      return false;
    }).toList();
  }

  /// Extrai ID √∫nico do item
  String _getItemId(dynamic item) {
    if (item is LawyerModel) return 'lawyer_${item.id}';
    if (item is LawFirmModel) return 'firm_${item.id}';
    return 'unknown_${item.hashCode}';
  }
}
