{"version":3,"file":"daily-react.cjs.production.min.js","sources":["../src/DailyContext.tsx","../src/hooks/useDaily.ts","../src/DailyEventContext.tsx","../src/hooks/useDailyEvent.ts","../src/lib/customDeepEqual.ts","../src/lib/jotai-custom.ts","../src/hooks/useParticipantProperty.ts","../src/hooks/useThrottledDailyEvent.ts","../src/utils/getParticipantPaths.ts","../src/utils/resolveParticipantPaths.ts","../src/DailyParticipants.tsx","../src/hooks/useLocalSessionId.ts","../src/hooks/useActiveSpeakerId.ts","../src/utils/isTrackOff.ts","../src/hooks/useParticipantIds.ts","../src/hooks/useScreenShare.ts","../src/hooks/useMediaTrack.ts","../src/hooks/useMergedRef.ts","../src/components/DailyAudioTrack.tsx","../src/components/DailyAudio.tsx","../src/components/DailyVideo.tsx","../src/DailyDevicesContext.tsx","../src/DailyDevices.tsx","../src/DailyLiveStreaming.tsx","../src/DailyMeeting.tsx","../src/DailyNetwork.tsx","../src/DailyRecordings.tsx","../src/hooks/useMeetingState.ts","../src/DailyRoom.tsx","../src/DailyTranscriptions.tsx","../src/hooks/useCallInstance.ts","../src/hooks/useCallObject.ts","../src/hooks/useParticipant.ts","../src/lib/inlineAudioWorklet.ts","../src/hooks/useCPULoad.ts","../src/hooks/useDailyError.ts","../src/hooks/useInputSettings.ts","../src/hooks/useParticipantCounts.ts","../src/hooks/useReceiveSettings.ts","../src/hooks/useRoom.ts","../src/hooks/useSendSettings.ts","../src/DailyProvider.tsx","../src/hooks/useActiveParticipant.ts","../src/hooks/useAppMessage.ts","../src/hooks/useAudioLevel.ts","../src/hooks/useAudioLevelObserver.ts","../src/hooks/useAudioTrack.ts","../src/hooks/useCallFrame.ts","../src/hooks/useDevices.ts","../src/hooks/useLiveStreaming.ts","../src/hooks/useLocalParticipant.ts","../src/hooks/useMeetingSessionState.ts","../src/hooks/useNetwork.ts","../src/hooks/usePermissions.ts","../src/hooks/useRecording.ts","../src/hooks/useRoomExp.ts","../src/hooks/useScreenAudioTrack.ts","../src/hooks/useScreenVideoTrack.ts","../src/hooks/useTranscription.ts","../src/hooks/useVideoTrack.ts","../src/hooks/useWaitingParticipants.ts"],"sourcesContent":["import { DailyCall } from '@daily-co/daily-js';\nimport { createContext } from 'react';\n\nexport const DailyContext = createContext<DailyCall | null>(null);\n","import { useContext, useDebugValue } from 'react';\n\nimport { DailyContext } from '../DailyContext';\n\n/**\n * Returns callObject instance passed to or created by closest <DailyProvider>.\n */\nexport const useDaily = () => {\n  const daily = useContext(DailyContext);\n  useDebugValue(daily);\n  return daily;\n};\n","import { DailyEvent } from '@daily-co/daily-js';\nimport { createContext } from 'react';\n\ninterface EventContextValue {\n  on(ev: DailyEvent, callback: Function, key: number): void;\n  off(ev: DailyEvent, key: number): void;\n}\n\nexport const DailyEventContext = createContext<EventContextValue>({\n  on: () => {},\n  off: () => {},\n});\n","import { DailyEvent, DailyEventObject } from '@daily-co/daily-js';\nimport {\n  useContext,\n  useDebugValue,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\n\nimport { DailyEventContext } from '../DailyEventContext';\n\ntype EventCallback<T extends DailyEvent> = (event: DailyEventObject<T>) => void;\n\nlet priorityCounter = -1;\nexport const getPriorityUnique = () => priorityCounter--;\nlet uniqueCounter = 1;\nexport const getUnique = () => uniqueCounter++;\n\n/**\n * Sets up a daily event listener using [on](https://docs.daily.co/reference/daily-js/instance-methods/on) method.\n * When this hook is unmounted the event listener is unregistered using [off](https://docs.daily.co/reference/daily-js/instance-methods/off).\n *\n * Warning: callback has to be a memoized reference (e.g. via [useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback)).\n * Otherwise a console error might be thrown indicating a re-render loop issue.\n *\n * @param ev The DailyEvent to register.\n * @param callback A memoized callback reference to run when the event is emitted.\n */\nexport const useDailyEvent = <T extends DailyEvent>(\n  ev: T,\n  callback: EventCallback<T>,\n  INTERNAL_priority = false\n) => {\n  const { off, on } = useContext(DailyEventContext);\n  const [isBlocked, setIsBlocked] = useState(false);\n  const reassignCount = useRef<number>(0);\n\n  const eventId = useMemo(\n    () => (INTERNAL_priority ? getPriorityUnique() : getUnique()),\n    [INTERNAL_priority]\n  );\n\n  useEffect(() => {\n    if (!ev || isBlocked) return;\n    /**\n     * Check if callback has been reassigned often enough without hitting the 50ms timeout.\n     */\n    if (reassignCount.current > 100000) {\n      console.error(\n        `useDailyEvent called with potentially non-memoized event callback or due to too many re-renders.\n        Memoize using useCallback to avoid re-render loop or reduce the amount of state transitions the callback depends on.\n        Passed callback for '${ev}' event is NOT registered.`,\n        callback\n      );\n      setIsBlocked(true);\n      return;\n    }\n    reassignCount.current++;\n    const timeout = setTimeout(() => {\n      reassignCount.current = 0;\n    }, 50);\n    on(ev, callback, eventId);\n    return () => {\n      clearTimeout(timeout);\n      off(ev, eventId);\n    };\n  }, [callback, ev, eventId, isBlocked, off, on]);\n\n  useDebugValue({\n    event: ev,\n    eventId,\n    isBlocked,\n    callback,\n  });\n};\n","/**\n * Compares two variables for deep equality.\n * Gracefully handles equality checks on MediaStreamTracks by comparing their ids.\n */\nexport function customDeepEqual(a: any, b: any): boolean {\n  if (a === b) return true;\n\n  // Handle arrays separately\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!customDeepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  // Handle specific cases like MediaStream, MediaStreamTrack, Date, etc.\n  if (MediaStream) {\n    if (a instanceof MediaStream && b instanceof MediaStream) {\n      return (\n        a.id === b.id &&\n        a.active === b.active &&\n        a.getTracks().length === b.getTracks().length &&\n        a\n          .getTracks()\n          .every((track, idx) => customDeepEqual(track, b.getTracks()[idx]))\n      );\n    }\n  }\n\n  // Handle special case for MediaStreamTrack\n  if (MediaStreamTrack) {\n    if (a instanceof MediaStreamTrack && b instanceof MediaStreamTrack) {\n      return (\n        a.id === b.id && a.kind === b.kind && a.readyState === b.readyState\n      );\n    }\n  }\n\n  // Handle special case for Date\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  // Handle special case for RegExp\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.flags === b.flags;\n  }\n\n  // Handle Set comparisons\n  if (a instanceof Set && b instanceof Set) {\n    if (a.size !== b.size) return false;\n    const arrA = Array.from(a).sort();\n    const arrB = Array.from(b).sort();\n    return arrA.every((val, idx) => customDeepEqual(val, arrB[idx]));\n  }\n\n  // Handle Map comparisons\n  if (a instanceof Map && b instanceof Map) {\n    if (a.size !== b.size) return false;\n    for (const [key, value] of a.entries()) {\n      if (!b.has(key) || !customDeepEqual(value, b.get(key))) return false;\n    }\n    return true;\n  }\n\n  // Primitive types and null checks\n  if (\n    typeof a !== 'object' ||\n    a === null ||\n    typeof b !== 'object' ||\n    b === null\n  ) {\n    return false;\n  }\n\n  // Generic object handling\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n\n  for (let i = 0; i < keysA.length; i++) {\n    const key = keysA[i];\n    if (\n      !Object.prototype.hasOwnProperty.call(b, key) ||\n      !customDeepEqual(a[key], b[key])\n    ) {\n      return false;\n    }\n  }\n\n  // All keys and values match -> the objects are deeply equal\n  return true;\n}\n\n/**\n * Comparison function optimized for comparing arrays.\n */\nexport function arraysDeepEqual(a: any[], b: any[]) {\n  // Check for reference equality\n  if (a === b) return true;\n\n  // Check if both arrays are of the same length\n  if (a.length !== b.length) return false;\n\n  // Compare each element in the array\n  for (let i = 0; i < a.length; i++) {\n    const valueA = a[i];\n    const valueB = b[i];\n\n    const isComplexTypeA = valueA !== null && typeof valueA === 'object';\n    const isComplexTypeB = valueB !== null && typeof valueB === 'object';\n\n    // Use customDeepEqual only if either value is a complex type\n    if (isComplexTypeA || isComplexTypeB) {\n      if (!customDeepEqual(valueA, valueB)) return false;\n    } else if (valueA !== valueB) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { atom, Getter, WritableAtom } from 'jotai';\n\nexport function jotaiDebugLabel(label: string) {\n  return 'daily-react-' + label;\n}\n\ninterface EqualAtomOptions<T> {\n  key?: string;\n  get: () => T;\n  equals: (a: T, b: T) => boolean;\n}\n\n/**\n * Same API as Recoil's selector but with an additional `equals` key.\n * Allows to run custom equality checks before returning a new calculated value.\n * Use this when returning non-primitive types from state.\n */\nexport function equalAtom<T>(options: EqualAtomOptions<T>) {\n  const baseAtom = atom(options.get);\n  const derivedAtom = atom((get) => {\n    const latest = get(baseAtom);\n    if (prior !== undefined && options.equals(latest, prior)) {\n      return prior;\n    }\n    prior = latest;\n    return latest;\n  });\n\n  let prior: T | undefined;\n  return derivedAtom;\n}\n\n/**\n * A custom implementation of `equalAtomFamily` for Jotai,\n * providing similar functionality to Recoil's `selectorFamily`\n * with an additional `equals` key for custom equality checks.\n */\ninterface EqualAtomFamilyOptions<T, P> {\n  get: (param: P) => (get: Getter) => T;\n  equals: (a: T, b: T) => boolean;\n}\n\nexport function equalAtomFamily<T extends unknown[], P>(\n  options: EqualAtomFamilyOptions<T, P>\n): (param: P) => WritableAtom<T, T, void> {\n  const atomCache = new Map<P, WritableAtom<T, T, void>>();\n  const priorValues: Map<P, T | undefined> = new Map();\n\n  return (param: P) => {\n    if (!atomCache.has(param)) {\n      const baseAtom = atom((get) => {\n        const derivedValue = options.get(param)(get);\n        const prior = priorValues.get(param);\n        if (prior != null && options.equals(derivedValue, prior)) {\n          return prior;\n        }\n        priorValues.set(param, derivedValue);\n        return derivedValue;\n      });\n\n      atomCache.set(param, baseAtom as WritableAtom<T, T, void>);\n    }\n\n    return atomCache.get(param)!;\n  };\n}\n","import { atom, useAtomValue } from 'jotai';\nimport { atomFamily } from 'jotai/utils';\nimport { useDebugValue } from 'react';\n\nimport { ExtendedDailyParticipant } from '../DailyParticipants';\nimport { arraysDeepEqual } from '../lib/customDeepEqual';\nimport { equalAtomFamily, jotaiDebugLabel } from '../lib/jotai-custom';\nimport type { NumericKeys } from '../types/NumericKeys';\nimport type { Paths } from '../types/paths';\nimport type { PathValue } from '../types/pathValue';\n\nconst DELIM = '::';\nconst PATHS_DELIM = ';';\nexport const getPropertyParam = (\n  id: string,\n  property: Paths<ExtendedDailyParticipant>\n) => id + DELIM + property;\nconst getPropertiesParam = (\n  id: string,\n  properties: Paths<ExtendedDailyParticipant>[]\n) => id + DELIM + properties.join(PATHS_DELIM);\n\nexport const getParticipantPropertyAtom = (\n  id: string,\n  property: Paths<ExtendedDailyParticipant>\n) => participantPropertyState(getPropertyParam(id, property));\n\n/**\n * Stores all property paths for a given participant.\n */\nexport const participantPropertyPathsState = atomFamily((id: string) => {\n  const participantPropertyPathsAtom = atom<Paths<ExtendedDailyParticipant>[]>(\n    []\n  );\n  participantPropertyPathsAtom.debugLabel = jotaiDebugLabel(\n    `participant-property-paths-${id}`\n  );\n  return participantPropertyPathsAtom;\n});\n\n/**\n * Stores resolved values for each participant and property path.\n */\nexport const participantPropertyState = atomFamily((param: string) => {\n  const participantPropertyAtom = atom<any>(null);\n  participantPropertyAtom.debugLabel = jotaiDebugLabel(\n    `participant-property-${param}`\n  );\n  return participantPropertyAtom;\n});\n\n/**\n * Stores resolved values for each participant and property path.\n */\nconst participantPropertiesState = equalAtomFamily<any[], string>({\n  equals: arraysDeepEqual,\n  get: (param: string) => (get) => {\n    const [id, paths] = param.split(DELIM);\n    const properties = paths.split(PATHS_DELIM);\n    return properties.map((path) =>\n      get(\n        getParticipantPropertyAtom(id, path as Paths<ExtendedDailyParticipant>)\n      )\n    );\n  },\n});\n\ntype UseParticipantPropertyReturnType<\n  T extends ExtendedDailyParticipant,\n  P extends Paths<T> | Paths<T>[]\n> = P extends Paths<T>[]\n  ? { [K in keyof P]: K extends NumericKeys ? PathValue<T, P[K]> : unknown }\n  : P extends Paths<T>\n  ? PathValue<T, P>\n  : never;\n\n/**\n * Returns a participant's property that you subscribe to.\n * @param participantId The participant's session_id.\n * @param propertyPaths the array of participant property that you want to subscribe to.\n */\nexport const useParticipantProperty = <\n  T extends ExtendedDailyParticipant = ExtendedDailyParticipant,\n  P extends Paths<T> | [Paths<T>, ...Paths<T>[]] =\n    | Paths<T>\n    | [Paths<T>, ...Paths<T>[]]\n>(\n  participantId: string,\n  propertyPaths: P\n): UseParticipantPropertyReturnType<T, P> => {\n  const properties = useAtomValue(\n    Array.isArray(propertyPaths)\n      ? participantPropertiesState(\n          getPropertiesParam(\n            participantId,\n            propertyPaths as Paths<ExtendedDailyParticipant>[]\n          )\n        )\n      : participantPropertyState(\n          getPropertyParam(\n            participantId,\n            propertyPaths as Paths<ExtendedDailyParticipant>\n          )\n        )\n  );\n\n  useDebugValue(\n    Array.isArray(propertyPaths)\n      ? propertyPaths.reduce(\n          (o: Record<any, any>, path: Paths<T>, i: number) => {\n            o[path] = properties[i];\n            return o;\n          },\n          {}\n        )\n      : {\n          [propertyPaths as any]: properties,\n        }\n  );\n\n  return properties;\n};\n","import { DailyEvent, DailyEventObject } from '@daily-co/daily-js';\nimport throttle from 'lodash.throttle';\nimport {\n  useCallback,\n  useContext,\n  useDebugValue,\n  useEffect,\n  useMemo,\n  useRef,\n} from 'react';\n\nimport { DailyEventContext } from '../DailyEventContext';\nimport { getPriorityUnique, getUnique, useDailyEvent } from './useDailyEvent';\n\ntype EnsureArray<T> = T extends DailyEvent ? [T] : T;\n\ntype EventObjectsFor<T> = EnsureArray<T> extends (infer U)[]\n  ? U extends DailyEvent\n    ? DailyEventObject<U>\n    : never\n  : never;\n\ntype EventCallback<T extends DailyEvent | DailyEvent[]> = (\n  events: EventObjectsFor<T>[]\n) => void;\n\n/**\n * Sets up a throttled daily event listener using [on](https://docs.daily.co/reference/daily-js/instance-methods/on) method.\n * When this hook is unmounted the event listener is unregistered using [off](https://docs.daily.co/reference/daily-js/instance-methods/off).\n *\n * In comparison to useDailyEvent the callback passed here will be called with an array of event objects.\n *\n * You can pass an array of DailyEvents to register multiple daily events with a single callback handler.\n * The events returned in the callback parameter are guaranteed to be in the same order as they were emitted.\n *\n * @param ev The DailyEvent to register or an array of DailyEvent to register.\n * @param callback A memoized callback reference to run when throttled events are emitted.\n * @param throttleTimeout The minimum waiting time until the callback is called again. Default: 500\n */\nexport const useThrottledDailyEvent = <T extends DailyEvent>(\n  ev: T | T[],\n  callback: EventCallback<EnsureArray<T>>,\n  throttleTimeout = 500,\n  INTERNAL_priority = false\n) => {\n  const { off, on } = useContext(DailyEventContext);\n  const eventId = useMemo(() => {\n    if (Array.isArray(ev))\n      return ev.reduce<Record<string, number>>((r, e) => {\n        r[e] = INTERNAL_priority ? getPriorityUnique() : getUnique();\n        return r;\n      }, {});\n    return { [ev]: INTERNAL_priority ? getPriorityUnique() : getUnique() };\n  }, [ev, INTERNAL_priority]);\n\n  const throttledEvents = useRef<EventObjectsFor<T>[]>([]);\n\n  useDailyEvent(\n    'call-instance-destroyed',\n    useCallback(() => {\n      throttledEvents.current.length = 0;\n    }, [])\n  );\n\n  const emitEvents = useMemo(\n    () =>\n      throttle(\n        () => {\n          if (throttledEvents.current.length === 0) return;\n          callback(throttledEvents.current);\n          throttledEvents.current.length = 0;\n        },\n        throttleTimeout,\n        {\n          trailing: true,\n        }\n      ),\n    [callback, throttleTimeout]\n  );\n\n  useEffect(() => {\n    if (!ev) return;\n    const addEvent = (ev: DailyEventObject) => {\n      throttledEvents.current.push(ev);\n      emitEvents();\n    };\n    if (Array.isArray(ev)) {\n      ev.forEach((e) => on(e, addEvent, eventId[e]));\n    } else {\n      on(ev, addEvent, eventId[ev]);\n    }\n    return () => {\n      if (Array.isArray(ev)) {\n        ev.forEach((e) => off(e, eventId[e]));\n      } else {\n        off(ev, eventId[ev]);\n      }\n    };\n  }, [emitEvents, ev, eventId, off, on]);\n\n  useDebugValue({\n    event: ev,\n    eventId,\n  });\n};\n","import { ExtendedDailyParticipant } from '../DailyParticipants';\nimport { Paths } from '../types/paths';\n\n/**\n * Returns all property paths for an object.\n */\nconst getPaths = (\n  o: Record<any, any>,\n  currentPath = '',\n  visited = new Set()\n): string[] => {\n  if (typeof o !== 'object' || o === null || visited.has(o)) {\n    return [currentPath];\n  }\n\n  visited.add(o);\n\n  const paths = [];\n  for (const key in o) {\n    if (Object.prototype.hasOwnProperty.call(o, key)) {\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\n      paths.push(newPath, ...getPaths(o[key], newPath, visited));\n    }\n  }\n\n  visited.delete(o);\n\n  return paths;\n};\n\n/**\n * Returns all property paths for a given participant object.\n */\nexport const getParticipantPaths = (p: ExtendedDailyParticipant) => {\n  return getPaths(p) as Paths<ExtendedDailyParticipant>[];\n};\n","import { ExtendedDailyParticipant } from '../DailyParticipants';\nimport type { NumericKeys } from '../types/NumericKeys';\nimport type { Paths } from '../types/paths';\nimport type { PathValue } from '../types/pathValue';\n\nconst resolvePath = <T extends ExtendedDailyParticipant, P extends Paths<T>>(\n  participant: T | null,\n  path: P\n): PathValue<T, P> => {\n  return String(path)\n    .split('.')\n    .filter((key) => key.length)\n    .reduce((p: any, key) => p && p[key], participant);\n};\n\ntype ResolveParticipantPathsReturnType<\n  T extends ExtendedDailyParticipant,\n  P extends Paths<T>[]\n> = { [K in keyof P]: K extends NumericKeys ? PathValue<T, P[K]> : never };\n\nexport const resolveParticipantPaths = <\n  T extends ExtendedDailyParticipant,\n  P extends Paths<T>[]\n>(\n  participant: T | null,\n  paths: P\n): ResolveParticipantPathsReturnType<T, P> => {\n  return paths.map((path) =>\n    resolvePath(participant, path)\n  ) as ResolveParticipantPathsReturnType<T, P>;\n};\n","import {\n  DailyParticipant,\n  DailyParticipantsObject,\n  DailyParticipantTracks,\n  DailyWaitingParticipant,\n} from '@daily-co/daily-js';\nimport { atom } from 'jotai';\nimport { atomFamily, useAtomCallback } from 'jotai/utils';\nimport React, { useCallback, useEffect, useState } from 'react';\n\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport {\n  getParticipantPropertyAtom,\n  getPropertyParam,\n  participantPropertyPathsState,\n  participantPropertyState,\n} from './hooks/useParticipantProperty';\nimport { useThrottledDailyEvent } from './hooks/useThrottledDailyEvent';\nimport { arraysDeepEqual, customDeepEqual } from './lib/customDeepEqual';\nimport { equalAtomFamily, jotaiDebugLabel } from './lib/jotai-custom';\nimport { getParticipantPaths } from './utils/getParticipantPaths';\nimport { resolveParticipantPaths } from './utils/resolveParticipantPaths';\n\n/**\n * Extends DailyParticipant with convenient additional properties.\n * The `tracks` object needs to omit custom track keys, otherwise\n * autocomplete for `tracks` in useParticipantProperty doesn't work.\n */\nexport interface ExtendedDailyParticipant\n  extends Omit<DailyParticipant, 'tracks'> {\n  last_active?: Date;\n  tracks: DailyParticipantTracks;\n}\n\n/**\n * Stores the most recent peerId as reported from [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.\n */\nexport const activeIdState = atom<string | null>(null);\nactiveIdState.debugLabel = jotaiDebugLabel('active-id');\n\nexport const localIdState = atom<string>('');\nlocalIdState.debugLabel = jotaiDebugLabel('local-id');\n\nexport const localJoinDateState = atom<Date | null>(null);\nlocalJoinDateState.debugLabel = jotaiDebugLabel('local-join-date');\n\nexport const participantIdsState = atom<string[]>([]);\nparticipantIdsState.debugLabel = jotaiDebugLabel('participant-ids');\n\nexport const participantState = atomFamily((id: string) => {\n  const participantAtom = atom<ExtendedDailyParticipant | null>(null);\n  participantAtom.debugLabel = jotaiDebugLabel(`participant-${id}`);\n  return participantAtom;\n});\nexport const waitingParticipantsState = atom<string[]>([]);\nwaitingParticipantsState.debugLabel = jotaiDebugLabel('waiting-participants');\n\nexport const waitingParticipantState = atomFamily((id: string) => {\n  const waitingParticipantAtom = atom<DailyWaitingParticipant>({\n    awaitingAccess: {\n      level: 'full',\n    },\n    id,\n    name: '',\n  });\n  waitingParticipantAtom.debugLabel = jotaiDebugLabel(\n    `waiting-participant-${id}`\n  );\n  return waitingParticipantAtom;\n});\n\nexport const allWaitingParticipantsSelector = equalAtomFamily<\n  any[],\n  DailyWaitingParticipant | undefined\n>({\n  equals: arraysDeepEqual,\n  get: () => (get) => {\n    const ids = get(waitingParticipantsState);\n    return ids.map((id) => get(waitingParticipantState(id)));\n  },\n});\n\nexport const DailyParticipants: React.FC<React.PropsWithChildren<unknown>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n  const [initialized, setInitialized] = useState(false);\n\n  const initParticipants = useAtomCallback(\n    useCallback((_get, set, participants: DailyParticipantsObject) => {\n      set(localIdState, participants.local.session_id);\n      const participantsArray = Object.values(participants);\n      const ids = participantsArray.map((p) => p.session_id);\n      set(participantIdsState, ids);\n      participantsArray.forEach((p) => {\n        set(participantState(p.session_id), p);\n        const paths = getParticipantPaths(p);\n        set(participantPropertyPathsState(p.session_id), paths);\n        paths.forEach((property) => {\n          const [value] = resolveParticipantPaths(\n            p as ExtendedDailyParticipant,\n            [property]\n          );\n          set(getParticipantPropertyAtom(p.session_id, property), value);\n        });\n      });\n      setInitialized(true);\n    }, [])\n  );\n\n  /**\n   * Initialize participants state based on daily.participants().\n   * Retries every 100ms to initialize the state, until daily is ready.\n   */\n  useEffect(() => {\n    if (!daily || initialized) return;\n    const interval = setInterval(() => {\n      const participants = daily.participants();\n      if (!('local' in participants)) return;\n      initParticipants(participants);\n      clearInterval(interval);\n    }, 100);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [daily, initialized, initParticipants]);\n  const handleInitEvent = useCallback(() => {\n    if (!daily) return;\n    const participants = daily?.participants();\n    if (!participants.local) return;\n    initParticipants(participants);\n  }, [daily, initParticipants]);\n  useDailyEvent('started-camera', handleInitEvent, true);\n  useDailyEvent('access-state-updated', handleInitEvent, true);\n  useDailyEvent(\n    'joining-meeting',\n    useAtomCallback(\n      useCallback(\n        (_get, set) => {\n          set(localJoinDateState, new Date());\n          handleInitEvent();\n        },\n        [handleInitEvent]\n      )\n    ),\n    true\n  );\n  useDailyEvent(\n    'joined-meeting',\n    useCallback(\n      (ev) => {\n        initParticipants(ev.participants);\n      },\n      [initParticipants]\n    ),\n    true\n  );\n\n  /**\n   * Reset stored participants, when meeting has ended.\n   */\n  const handleCleanup = useAtomCallback(\n    useCallback((get, set) => {\n      set(localIdState, '');\n      set(activeIdState, null);\n      const ids = get(participantIdsState);\n      ids.forEach((id) => participantState.remove(id));\n      set(participantIdsState, []);\n    }, [])\n  );\n  useDailyEvent('call-instance-destroyed', handleCleanup, true);\n  useDailyEvent('left-meeting', handleCleanup, true);\n\n  useThrottledDailyEvent(\n    [\n      'active-speaker-change',\n      'participant-joined',\n      'participant-updated',\n      'participant-left',\n    ],\n    useAtomCallback(\n      useCallback((get, set, evts) => {\n        if (!evts.length) return;\n        evts.forEach((ev) => {\n          switch (ev.action) {\n            case 'active-speaker-change': {\n              set(activeIdState, ev.activeSpeaker.peerId);\n              set(participantState(ev.activeSpeaker.peerId), (prev) => {\n                if (!prev) return null;\n                return {\n                  ...prev,\n                  last_active: new Date(),\n                };\n              });\n              break;\n            }\n            case 'participant-joined': {\n              // Update list of ids\n              set(participantIdsState, (prevIds) =>\n                prevIds.includes(ev.participant.session_id)\n                  ? prevIds\n                  : [...prevIds, ev.participant.session_id]\n              );\n              // Store entire object\n              set(participantState(ev.participant.session_id), ev.participant);\n\n              const paths = getParticipantPaths(ev.participant);\n              // Set list of property paths\n              set(\n                participantPropertyPathsState(ev.participant.session_id),\n                paths\n              );\n              // Set all property path values\n              paths.forEach((property) => {\n                const [value] = resolveParticipantPaths(\n                  ev.participant as ExtendedDailyParticipant,\n                  [property]\n                );\n                set(\n                  getParticipantPropertyAtom(\n                    ev.participant.session_id,\n                    property\n                  ),\n                  value\n                );\n              });\n              break;\n            }\n            case 'participant-updated': {\n              // Update entire object\n              set(participantState(ev.participant.session_id), ev.participant);\n              // Update local session_id\n              if (ev.participant.local) {\n                set(localIdState, ev.participant.session_id);\n              }\n\n              const paths = getParticipantPaths(ev.participant);\n              const oldPaths = get(\n                participantPropertyPathsState(ev.participant.session_id)\n              );\n              const pathsChanged =\n                paths.length !== oldPaths.length ||\n                paths.some((path) => !oldPaths.includes(path));\n              // Set list of property paths\n              if (pathsChanged) {\n                set(\n                  participantPropertyPathsState(ev.participant.session_id),\n                  paths\n                );\n              }\n\n              // Create a Set of oldPaths for quick lookup\n              const oldPathSet = new Set(oldPaths);\n\n              // Resolve all path values in one call\n              const resolvedValues = resolveParticipantPaths(\n                ev.participant as ExtendedDailyParticipant,\n                paths\n              );\n\n              paths.forEach((property, idx) => {\n                const value = resolvedValues[idx];\n\n                // Remove property from oldPathSet to mark it as processed\n                oldPathSet.delete(property);\n\n                // Only update if the new value differs from the current one\n                set(\n                  getParticipantPropertyAtom(\n                    ev.participant.session_id,\n                    property\n                  ),\n                  (prev: any) => (customDeepEqual(prev, value) ? prev : value)\n                );\n              });\n\n              // Set any remaining paths in oldPathSet to null\n              oldPathSet.forEach((property) => {\n                set(\n                  getParticipantPropertyAtom(\n                    ev.participant.session_id,\n                    property\n                  ),\n                  null\n                );\n              });\n              break;\n            }\n            case 'participant-left': {\n              // Remove from list of ids\n              set(participantIdsState, (prevIds) =>\n                prevIds.includes(ev.participant.session_id)\n                  ? prevIds.filter((id) => id !== ev.participant.session_id)\n                  : prevIds\n              );\n              // Remove entire object\n              participantState.remove(ev.participant.session_id);\n\n              const oldPaths = get(\n                participantPropertyPathsState(ev.participant.session_id)\n              );\n              // Remove property path values\n              oldPaths.forEach((property) => {\n                participantPropertyState.remove(\n                  getPropertyParam(ev.participant.session_id, property)\n                );\n              });\n              // Remove all property paths\n              participantPropertyPathsState.remove(ev.participant.session_id);\n              break;\n            }\n          }\n        });\n      }, [])\n    ),\n    100,\n    true\n  );\n\n  useThrottledDailyEvent(\n    [\n      'waiting-participant-added',\n      'waiting-participant-updated',\n      'waiting-participant-removed',\n    ],\n    useAtomCallback(\n      useCallback((_get, set, evts) => {\n        evts.forEach((ev) => {\n          switch (ev.action) {\n            case 'waiting-participant-added':\n              set(waitingParticipantsState, (wps) =>\n                wps.includes(ev.participant.id)\n                  ? wps\n                  : [...wps, ev.participant.id]\n              );\n              set(waitingParticipantState(ev.participant.id), ev.participant);\n              break;\n            case 'waiting-participant-updated':\n              set(waitingParticipantState(ev.participant.id), ev.participant);\n              break;\n            case 'waiting-participant-removed':\n              set(waitingParticipantsState, (wps) =>\n                wps.filter((wp) => wp !== ev.participant.id)\n              );\n              waitingParticipantState.remove(ev.participant.id);\n              break;\n          }\n        });\n      }, [])\n    ),\n    100,\n    true\n  );\n\n  return <>{children}</>;\n};\n","import { useAtomValue } from 'jotai';\nimport { useDebugValue } from 'react';\n\nimport { localIdState } from '../DailyParticipants';\n\n/**\n * Returns the local participant's session_id or empty string '',\n * if the local participant doesn't exist.\n */\nexport const useLocalSessionId = () => {\n  const localId = useAtomValue(localIdState);\n  useDebugValue(localId);\n  return localId;\n};\n","import { useAtomValue } from 'jotai';\nimport { useDebugValue, useEffect, useState } from 'react';\n\nimport { activeIdState } from '../DailyParticipants';\nimport { useLocalSessionId } from './useLocalSessionId';\n\ninterface UseActiveSpeakerIdArgs {\n  /**\n   * Anytime the active-speaker-change event emits a new id, this callback can be used\n   * to determine if the new speaker id should be ignored or not.\n   * Return false from the callback to ignore the new speaker id in this hook's instance.\n   */\n  filter?(id: string | null): boolean;\n  /**\n   * If set to true, useActiveParticipant will never return the local participant.\n   */\n  ignoreLocal?: boolean;\n}\n\nconst noopFilter = () => true;\n\n/**\n * Returns the most recent speaker id mentioned in an [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.\n */\nexport const useActiveSpeakerId = ({\n  filter = noopFilter,\n  ignoreLocal = false,\n}: UseActiveSpeakerIdArgs = {}) => {\n  const localSessionId = useLocalSessionId();\n  const recentActiveId = useAtomValue(activeIdState);\n  const isIgnoredLocalId = ignoreLocal && recentActiveId === localSessionId;\n  const isFilteredOut = !filter?.(recentActiveId);\n  const isRecentIdRelevant = !isIgnoredLocalId && !isFilteredOut;\n  const [activeId, setActiveId] = useState<string | null>(\n    isRecentIdRelevant ? recentActiveId : null\n  );\n\n  useEffect(() => {\n    if (isIgnoredLocalId || isFilteredOut) return;\n    setActiveId(recentActiveId);\n  }, [isFilteredOut, isIgnoredLocalId, recentActiveId]);\n\n  useDebugValue(activeId);\n\n  return activeId;\n};\n","import { DailyTrackState } from '@daily-co/daily-js';\n\nexport const isTrackOff = (trackState: DailyTrackState['state']) =>\n  ['blocked', 'off'].includes(trackState);\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { Atom } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport { useCallback, useDebugValue, useEffect, useState } from 'react';\n\nimport {\n  ExtendedDailyParticipant,\n  participantIdsState,\n  participantState,\n} from '../DailyParticipants';\nimport { customDeepEqual } from '../lib/customDeepEqual';\nimport { equalAtomFamily } from '../lib/jotai-custom';\nimport { isTrackOff } from '../utils/isTrackOff';\nimport { getParticipantPropertyAtom } from './useParticipantProperty';\nimport { useThrottledDailyEvent } from './useThrottledDailyEvent';\n\n// Define the type for the get function\ntype GetFunction = <T>(atom: Atom<T>) => T;\n\ntype FilterParticipantsFunction = (\n  p: ExtendedDailyParticipant,\n  index: number,\n  arr: ExtendedDailyParticipant[]\n) => boolean;\ntype SerializableFilterParticipants =\n  | 'local'\n  | 'remote'\n  | 'owner'\n  | 'record'\n  | 'screen';\ntype FilterParticipants =\n  | SerializableFilterParticipants\n  | FilterParticipantsFunction;\n\ntype SortParticipantsFunction = (\n  a: ExtendedDailyParticipant,\n  b: ExtendedDailyParticipant\n) => 1 | -1 | 0;\ntype SerializableSortParticipants =\n  | 'joined_at'\n  | 'session_id'\n  | 'user_id'\n  | 'user_name';\ntype SortParticipants = SerializableSortParticipants | SortParticipantsFunction;\n\nconst SERIALIZABLE_DELIM = ';';\nexport const getParticipantIdsFilterSortParam = (\n  filter: string | null,\n  sort: string | null\n) => `${filter}${SERIALIZABLE_DELIM}${sort}`;\n\n/**\n * Short-cut state selector for useParticipantIds({ filter: 'local' })\n */\nexport const participantIdsFilteredAndSortedState = equalAtomFamily<\n  string[],\n  string\n>({\n  equals: customDeepEqual,\n  get: (param) => (get) => {\n    const [filter, sort] = param.split(SERIALIZABLE_DELIM);\n    const ids = get(participantIdsState);\n    return ids\n      .filter((id) => {\n        switch (filter) {\n          /**\n           * Simple boolean fields first.\n           */\n          case 'local':\n          case 'owner':\n          case 'record': {\n            return get(getParticipantPropertyAtom(id, filter));\n          }\n          case 'remote': {\n            return !get(getParticipantPropertyAtom(id, 'local'));\n          }\n          case 'screen': {\n            const screenAudioState = get(\n              getParticipantPropertyAtom(id, 'tracks.screenAudio.state')\n            );\n            const screenVideoState = get(\n              getParticipantPropertyAtom(id, 'tracks.screenVideo.state')\n            );\n            return (\n              !isTrackOff(screenAudioState) || !isTrackOff(screenVideoState)\n            );\n          }\n          default:\n            return true;\n        }\n      })\n      .sort((idA, idB) => {\n        switch (sort) {\n          case 'joined_at':\n          case 'session_id':\n          case 'user_id':\n          case 'user_name': {\n            const aSort = get(getParticipantPropertyAtom(idA, sort));\n            const bSort = get(getParticipantPropertyAtom(idB, sort));\n            if (aSort !== undefined || bSort !== undefined) {\n              if (aSort === undefined) return -1;\n              if (bSort === undefined) return 1;\n              if (aSort > bSort) return 1;\n              if (aSort < bSort) return -1;\n            }\n            return 0;\n          }\n          default:\n            return 0;\n        }\n      });\n  },\n});\n\ninterface UseParticipantIdsArgs {\n  filter?: FilterParticipants;\n  onActiveSpeakerChange?(ev: DailyEventObject<'active-speaker-change'>): void;\n  onParticipantJoined?(ev: DailyEventObject<'participant-joined'>): void;\n  onParticipantLeft?(ev: DailyEventObject<'participant-left'>): void;\n  onParticipantUpdated?(ev: DailyEventObject<'participant-updated'>): void;\n  sort?: SortParticipants;\n}\n\n/**\n * Returns a list of participant ids (= session_id).\n * The list can optionally be filtered and sorted, using the filter and sort options.\n */\nexport const useParticipantIds = ({\n  filter,\n  onActiveSpeakerChange,\n  onParticipantJoined,\n  onParticipantLeft,\n  onParticipantUpdated,\n  sort,\n}: UseParticipantIdsArgs = {}) => {\n  /**\n   * For instances of useParticipantIds with string-based filter and sort,\n   * we can immediately return the correct ids from Jotai's state.\n   */\n  const preFilteredSortedIds = useAtomValue(\n    participantIdsFilteredAndSortedState(\n      getParticipantIdsFilterSortParam(\n        typeof filter === 'string' ? filter : null,\n        typeof sort === 'string' ? sort : null\n      )\n    )\n  );\n\n  const shouldUseCustomIds =\n    typeof filter === 'function' || typeof sort === 'function';\n\n  const getCustomFilteredIds = useCallback(\n    (get: GetFunction) => {\n      if (\n        // Ignore if both filter and sort are not functions.\n        typeof filter !== 'function' &&\n        typeof sort !== 'function'\n      )\n        return [];\n\n      const participants: (ExtendedDailyParticipant | null)[] =\n        preFilteredSortedIds.map((id) => get(participantState(id)));\n\n      return (\n        participants\n          // Make sure we don't accidentally try to filter/sort `null` participants\n          // This can happen when a participant's id is already present in store\n          // but the participant object is not stored, yet.\n          .filter((p): p is ExtendedDailyParticipant => Boolean(p))\n          // Run custom filter, if it's a function. Otherwise don't filter any participants.\n          .filter(typeof filter === 'function' ? filter : () => true)\n          // Run custom sort, if it's a function. Otherwise don't sort.\n          .sort(typeof sort === 'function' ? sort : () => 0)\n          // Map back to session_id.\n          .map((p) => p.session_id)\n          // Filter any potential null/undefined ids.\n          // This shouldn't really happen, but better safe than sorry.\n          .filter(Boolean)\n      );\n    },\n    [filter, preFilteredSortedIds, sort]\n  );\n\n  const [customIds, setCustomIds] = useState<string[]>([]);\n\n  const maybeUpdateCustomIds = useAtomCallback(\n    useCallback(\n      (get) => {\n        if (!shouldUseCustomIds) return;\n        const newIds = getCustomFilteredIds(get);\n        if (customDeepEqual(newIds, customIds)) return;\n        setCustomIds(newIds);\n      },\n      [customIds, getCustomFilteredIds, shouldUseCustomIds]\n    )\n  );\n\n  useEffect(() => {\n    maybeUpdateCustomIds();\n  }, [maybeUpdateCustomIds]);\n\n  useThrottledDailyEvent(\n    [\n      'participant-joined',\n      'participant-updated',\n      'active-speaker-change',\n      'participant-left',\n    ],\n    useCallback(\n      (evts) => {\n        if (!evts.length) return;\n        evts.forEach((ev) => {\n          switch (ev.action) {\n            case 'participant-joined':\n              onParticipantJoined?.(ev);\n              break;\n            case 'participant-updated':\n              onParticipantUpdated?.(ev);\n              break;\n            case 'active-speaker-change':\n              onActiveSpeakerChange?.(ev);\n              break;\n            case 'participant-left':\n              onParticipantLeft?.(ev);\n              break;\n          }\n        });\n        maybeUpdateCustomIds();\n      },\n      [\n        maybeUpdateCustomIds,\n        onActiveSpeakerChange,\n        onParticipantJoined,\n        onParticipantLeft,\n        onParticipantUpdated,\n      ]\n    )\n  );\n\n  const result =\n    typeof filter === 'function' || typeof sort === 'function'\n      ? customIds\n      : preFilteredSortedIds;\n\n  useDebugValue(result);\n\n  return result;\n};\n","import {\n  DailyCall,\n  DailyEventObjectNonFatalError,\n  DailyTrackState,\n} from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useCallback, useDebugValue } from 'react';\n\nimport { arraysDeepEqual } from '../lib/customDeepEqual';\nimport { equalAtomFamily } from '../lib/jotai-custom';\nimport { Reconstruct } from '../types/Reconstruct';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\nimport {\n  getParticipantIdsFilterSortParam,\n  participantIdsFilteredAndSortedState,\n} from './useParticipantIds';\nimport { getParticipantPropertyAtom } from './useParticipantProperty';\n\nexport interface ScreenShare {\n  local: boolean;\n  screenAudio: DailyTrackState;\n  screenVideo: DailyTrackState;\n  screenId: string;\n  session_id: string;\n}\n\nconst screenSharesState = equalAtomFamily<ScreenShare[], void>({\n  equals: arraysDeepEqual,\n  get: () => (get) => {\n    const screenIds = get(\n      participantIdsFilteredAndSortedState(\n        getParticipantIdsFilterSortParam('screen', null)\n      )\n    );\n    return screenIds.map<ScreenShare>((id) => {\n      return {\n        local: get(getParticipantPropertyAtom(id, 'local')),\n        screenAudio: get(getParticipantPropertyAtom(id, 'tracks.screenAudio')),\n        screenVideo: get(getParticipantPropertyAtom(id, 'tracks.screenVideo')),\n        screenId: `${id}-screen`,\n        session_id: id,\n      };\n    });\n  },\n});\n\ntype DailyEventObjectScreenShareError = Reconstruct<\n  DailyEventObjectNonFatalError,\n  'type',\n  'screen-share-error'\n>;\n\ninterface UseScreenShareArgs {\n  onError?(ev: DailyEventObjectScreenShareError): void;\n  onLocalScreenShareStarted?(): void;\n  onLocalScreenShareStopped?(): void;\n}\n\n/**\n * Allows access to information about shared screens, and methods to start or stop a local screen share.\n */\nexport const useScreenShare = ({\n  onError,\n  onLocalScreenShareStarted,\n  onLocalScreenShareStopped,\n}: UseScreenShareArgs = {}) => {\n  const daily = useDaily();\n\n  const startScreenShare = useCallback(\n    (...args: Parameters<DailyCall['startScreenShare']>) => {\n      daily?.startScreenShare(...args);\n    },\n    [daily]\n  );\n\n  const stopScreenShare = useCallback(\n    (...args: Parameters<DailyCall['stopScreenShare']>) => {\n      daily?.stopScreenShare(...args);\n    },\n    [daily]\n  );\n\n  useDailyEvent(\n    'local-screen-share-started',\n    useCallback(\n      () => onLocalScreenShareStarted?.(),\n      [onLocalScreenShareStarted]\n    )\n  );\n  useDailyEvent(\n    'local-screen-share-stopped',\n    useCallback(\n      () => onLocalScreenShareStopped?.(),\n      [onLocalScreenShareStopped]\n    )\n  );\n  useDailyEvent(\n    'nonfatal-error',\n    useCallback(\n      (ev) => {\n        if (ev.type !== 'screen-share-error') return;\n        onError?.(ev as DailyEventObjectScreenShareError);\n      },\n      [onError]\n    )\n  );\n\n  const screens = useAtomValue(screenSharesState(undefined));\n\n  const result = {\n    isSharingScreen: screens.some((s) => s.local),\n    screens,\n    startScreenShare,\n    stopScreenShare,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyParticipantTracks, DailyTrackState } from '@daily-co/daily-js';\nimport { useDebugValue } from 'react';\n\nimport { isTrackOff } from '../utils/isTrackOff';\nimport { useParticipantProperty } from './useParticipantProperty';\n\ntype MediaType = keyof DailyParticipantTracks;\n\nexport interface MediaTrackState extends DailyTrackState {\n  isOff: boolean;\n}\n\n/**\n * Returns a participant's track and state, based on the given MediaType.\n *\n * Equivalent to daily.participants()[participantId].tracks[type].\n *\n * @param participantId The participant's session_id.\n * @param type The track type. Default: \"video\"\n */\nexport const useMediaTrack = (\n  participantId: string,\n  type: MediaType = 'video'\n): MediaTrackState => {\n  const trackState = useParticipantProperty(participantId, `tracks.${type}`);\n\n  const result: MediaTrackState = trackState\n    ? {\n        ...trackState,\n        isOff: isTrackOff(trackState.state),\n      }\n    : {\n        isOff: true,\n        persistentTrack: undefined,\n        state: 'off',\n        subscribed: false,\n      };\n\n  useDebugValue(result);\n\n  return result;\n};\n","/**\n * Original source: https://github.com/jaredLunde/react-hook/blob/master/packages/merged-ref/src/index.tsx\n * Original author: Jared Lunde (https://github.com/jaredLunde)\n * Originally published under the MIT license: https://github.com/jaredLunde/react-hook/blob/master/LICENSE\n */\n\nimport React, { useCallback } from 'react';\n\nfunction useMergedRef<T>(...refs: React.Ref<T>[]): React.RefCallback<T> {\n  return useCallback(\n    (element: T) => {\n      for (let i = 0; i < refs.length; i++) {\n        const ref = refs[i];\n        if (typeof ref === 'function') ref(element);\n        else if (ref && typeof ref === 'object')\n          (ref as React.MutableRefObject<T>).current = element;\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    refs\n  );\n}\n\nexport default useMergedRef;\n","import React, { forwardRef, memo, useEffect, useRef } from 'react';\n\nimport { useMediaTrack } from '../hooks/useMediaTrack';\nimport useMergedRef from '../hooks/useMergedRef';\n\nexport interface DailyAudioPlayException {\n  name?: string;\n  message?: string;\n  sessionId: string;\n  target: HTMLAudioElement;\n  type: string;\n}\n\ninterface Props extends React.AudioHTMLAttributes<HTMLAudioElement> {\n  /**\n   * Callback to handle failed attempt to play audio.\n   */\n  onPlayFailed?(e: DailyAudioPlayException): void;\n  sessionId: string;\n  type?: 'audio' | 'screenAudio' | 'rmpAudio';\n}\n\nexport const DailyAudioTrack = memo(\n  forwardRef<HTMLAudioElement, Props>(\n    ({ onPlayFailed, sessionId, type = 'audio', ...props }, ref) => {\n      const audioEl = useRef<HTMLAudioElement>(null);\n      const audio = useMediaTrack(sessionId, type);\n      const audioRef = useMergedRef<HTMLAudioElement>(audioEl, ref);\n      const subscribedState = audio?.subscribed;\n\n      /**\n       * Setup audio tag.\n       */\n      useEffect(() => {\n        const audioTag = audioEl.current;\n        if (!audioTag || !audio?.persistentTrack) return;\n        let playTimeout: ReturnType<typeof setTimeout>;\n        const handleCanPlay = () => {\n          audioTag.play().catch((e) => {\n            onPlayFailed?.({\n              sessionId,\n              target: audioTag,\n              type,\n              message: e.message,\n              name: e.name,\n            });\n          });\n        };\n        const handlePlay = () => {\n          clearTimeout(playTimeout);\n        };\n        if (!MediaStream) {\n          console.warn(\n            `MediaStream API not available. Can't setup ${type} for ${sessionId}`\n          );\n          onPlayFailed?.({\n            sessionId,\n            target: audioTag,\n            type,\n            message: 'MediaStream API not available',\n            name: 'MediaStream API not available',\n          });\n          return;\n        }\n        audioTag.addEventListener('canplay', handleCanPlay);\n        audioTag.addEventListener('play', handlePlay);\n        audioTag.srcObject = new MediaStream([audio?.persistentTrack]);\n\n        return () => {\n          audioTag?.removeEventListener('canplay', handleCanPlay);\n          audioTag?.removeEventListener('play', handlePlay);\n        };\n      }, [audio?.persistentTrack, onPlayFailed, sessionId, type]);\n\n      return (\n        <audio\n          autoPlay\n          ref={audioRef}\n          {...props}\n          data-session-id={sessionId}\n          data-audio-type={type}\n          data-subscribed={subscribedState}\n        />\n      );\n    }\n  )\n);\nDailyAudioTrack.displayName = 'DailyAudioTrack';\n","import { useAtomCallback } from 'jotai/utils';\nimport React, {\n  forwardRef,\n  memo,\n  useCallback,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\n\nimport { ExtendedDailyParticipant } from '../DailyParticipants';\nimport { useActiveSpeakerId } from '../hooks/useActiveSpeakerId';\nimport { useDaily } from '../hooks/useDaily';\nimport { useLocalSessionId } from '../hooks/useLocalSessionId';\nimport { useParticipantIds } from '../hooks/useParticipantIds';\nimport { getParticipantPropertyAtom } from '../hooks/useParticipantProperty';\nimport { useScreenShare } from '../hooks/useScreenShare';\nimport { useThrottledDailyEvent } from '../hooks/useThrottledDailyEvent';\nimport { isTrackOff } from '../utils/isTrackOff';\nimport { DailyAudioPlayException, DailyAudioTrack } from './DailyAudioTrack';\n\ninterface Props {\n  /**\n   * When enabled and the call is configured for manual track subscriptions,\n   * DailyAudio will automatically subscribe to the active speaker's audio track.\n   */\n  autoSubscribeActiveSpeaker?: boolean;\n  /**\n   * Maximum amount of parallel speakers. Default: 5.\n   */\n  maxSpeakers?: number;\n  /**\n   * Callback to handle failed attempt to play audio.\n   */\n  onPlayFailed?(e: DailyAudioPlayException): void;\n  /**\n   * When enabled, plays audio from a local screenAudio track.\n   */\n  playLocalScreenAudio?: boolean;\n}\n\nexport interface DailyAudioHandle {\n  /**\n   * Returns all rendered audio elements.\n   */\n  getAllAudio(): HTMLAudioElement[];\n  /**\n   * Returns the audio element assigned to the current active speaker.\n   */\n  getActiveSpeakerAudio(): HTMLAudioElement | null;\n  /**\n   * Returns all rendered audio elements for rmpAudio tracks.\n   */\n  getRmpAudio(): HTMLAudioElement[];\n  /**\n   * Returns all rendered audio elements for screenAudio tracks.\n   */\n  getScreenAudio(): HTMLAudioElement[];\n  /**\n   * Returns the audio track for the given sessionId.\n   */\n  getAudioBySessionId(sessionId: string): HTMLAudioElement | null;\n  /**\n   * Returns the rmpAudio track for the given sessionId.\n   */\n  getRmpAudioBySessionId(sessionId: string): HTMLAudioElement | null;\n  /**\n   * Returns the screenAudio track for the given sessionId.\n   */\n  getScreenAudioBySessionId(sessionId: string): HTMLAudioElement | null;\n}\n\nexport const DailyAudio = memo(\n  forwardRef<DailyAudioHandle, Props>(\n    (\n      {\n        autoSubscribeActiveSpeaker = false,\n        maxSpeakers = 5,\n        onPlayFailed,\n        playLocalScreenAudio = false,\n      },\n      ref\n    ) => {\n      const daily = useDaily();\n      const [speakers, setSpeakers] = useState<string[]>(\n        new Array(maxSpeakers).fill('')\n      );\n      const { screens } = useScreenShare();\n      const localSessionId = useLocalSessionId();\n      const activeSpeakerId = useActiveSpeakerId({\n        ignoreLocal: true,\n      });\n\n      const containerRef = useRef<HTMLDivElement>(null);\n      useImperativeHandle(\n        ref,\n        () => ({\n          getActiveSpeakerAudio: () => {\n            return (\n              containerRef.current?.querySelector(\n                `audio[data-session-id=\"${activeSpeakerId}\"][data-audio-type=\"audio\"]`\n              ) ?? null\n            );\n          },\n          getAllAudio: () => {\n            return Array.from(\n              containerRef.current?.querySelectorAll('audio') ?? []\n            );\n          },\n          getAudioBySessionId: (id) => {\n            return (\n              containerRef.current?.querySelector(\n                `audio[data-session-id=\"${id}\"][data-audio-type=\"audio\"]`\n              ) ?? null\n            );\n          },\n          getRmpAudio: () => {\n            return Array.from(\n              containerRef.current?.querySelectorAll(\n                'audio[data-audio-type=\"rmpAudio\"]'\n              ) ?? []\n            );\n          },\n          getScreenAudio: () => {\n            return Array.from(\n              containerRef.current?.querySelectorAll(\n                'audio[data-audio-type=\"screenAudio\"]'\n              ) ?? []\n            );\n          },\n          getRmpAudioBySessionId: (id) => {\n            return (\n              containerRef.current?.querySelector(\n                `audio[data-session-id=\"${id}\"][data-audio-type=\"rmpAudio\"]`\n              ) ?? null\n            );\n          },\n          getScreenAudioBySessionId: (id) => {\n            return (\n              containerRef.current?.querySelector(\n                `audio[data-session-id=\"${id}\"][data-audio-type=\"screenAudio\"]`\n              ) ?? null\n            );\n          },\n        }),\n        [activeSpeakerId]\n      );\n\n      const assignSpeaker = useAtomCallback(\n        useCallback(\n          async (get, _set, sessionId: string) => {\n            /**\n             * Only consider remote participants with subscribed or staged audio.\n             */\n            const subscribedParticipants = Object.values(\n              daily?.participants() ?? {}\n            ).filter((p) => !p.local && Boolean(p.tracks.audio.subscribed));\n\n            const isSubscribed = (id: string) =>\n              subscribedParticipants.some((p) => p.session_id === id);\n\n            if (!isSubscribed(sessionId)) {\n              if (\n                daily &&\n                !daily.isDestroyed() &&\n                autoSubscribeActiveSpeaker &&\n                !daily.subscribeToTracksAutomatically()\n              ) {\n                daily.updateParticipant(sessionId, {\n                  setSubscribedTracks: {\n                    audio: true,\n                  },\n                });\n              } else {\n                return;\n              }\n            }\n\n            setSpeakers((prevSpeakers) => {\n              // New speaker is already present\n              if (prevSpeakers.includes(sessionId)) return prevSpeakers;\n\n              // Try to find a free slot: either unassigned or unsubscribed\n              const freeSlotCheck = (id: string) => !id || !isSubscribed(id);\n              if (prevSpeakers.some(freeSlotCheck)) {\n                const idx = prevSpeakers.findIndex(freeSlotCheck);\n                prevSpeakers[idx] = sessionId;\n                return [...prevSpeakers];\n              }\n\n              // From here on we can assume that all assigned audio tracks are subscribed.\n\n              // Try to find muted recent speaker\n              const mutedIdx = prevSpeakers.findIndex((id) =>\n                subscribedParticipants.some(\n                  (p) => p.session_id === id && isTrackOff(p.tracks.audio.state)\n                )\n              );\n              if (mutedIdx >= 0) {\n                prevSpeakers[mutedIdx] = sessionId;\n                return [...prevSpeakers];\n              }\n\n              // Find least recent non-active speaker and replace with new speaker\n              const speakerObjects = subscribedParticipants\n                .filter(\n                  (p) =>\n                    // Only consider participants currently assigned to speaker slots\n                    prevSpeakers.includes(p.session_id) &&\n                    // Don't replace current active participant, to avoid audio drop-outs\n                    p.session_id !== activeSpeakerId\n                )\n                .sort((a, b) => {\n                  const lastActiveA =\n                    get(\n                      getParticipantPropertyAtom(a.session_id, 'last_active')\n                    ) ?? new Date('1970-01-01');\n                  const lastActiveB =\n                    get(\n                      getParticipantPropertyAtom(b.session_id, 'last_active')\n                    ) ?? new Date('1970-01-01');\n                  if (lastActiveA > lastActiveB) return 1;\n                  if (lastActiveA < lastActiveB) return -1;\n                  return 0;\n                });\n\n              // No previous speaker in call anymore. Assign first free slot.\n              if (!speakerObjects.length) {\n                // Don't replace the active speaker. Instead find first non-active speaker slot.\n                const replaceIdx = prevSpeakers.findIndex(\n                  (id) => id !== activeSpeakerId\n                );\n                prevSpeakers[replaceIdx] = sessionId;\n                return [...prevSpeakers];\n              }\n\n              // Replace least recent speaker with new speaker\n              const replaceIdx = prevSpeakers.indexOf(\n                speakerObjects[0]?.session_id\n              );\n              prevSpeakers[replaceIdx] = sessionId;\n              return [...prevSpeakers];\n            });\n          },\n          [activeSpeakerId, autoSubscribeActiveSpeaker, daily]\n        )\n      );\n\n      /**\n       * Unassigns speaker from speaker slot, e.g. because participant left the call.\n       */\n      const removeSpeaker = useCallback((sessionId: string) => {\n        setSpeakers((prevSpeakers) => {\n          if (!prevSpeakers.includes(sessionId)) return prevSpeakers;\n          const newSpeakers = [...prevSpeakers];\n          const idx = newSpeakers.indexOf(sessionId);\n          newSpeakers[idx] = '';\n          return newSpeakers;\n        });\n      }, []);\n\n      useThrottledDailyEvent(\n        ['active-speaker-change', 'track-started', 'participant-left'],\n        useCallback(\n          (evts) => {\n            evts.forEach((ev) => {\n              switch (ev.action) {\n                case 'active-speaker-change':\n                  if (ev.activeSpeaker.peerId === localSessionId) return;\n                  assignSpeaker(ev.activeSpeaker.peerId);\n                  break;\n                case 'track-started':\n                  if (\n                    ev.track.kind === 'audio' &&\n                    ev.participant &&\n                    !ev.participant.local\n                  ) {\n                    assignSpeaker(ev.participant.session_id);\n                  }\n                  break;\n                case 'participant-left':\n                  removeSpeaker(ev.participant.session_id);\n                  break;\n              }\n            });\n          },\n          [assignSpeaker, localSessionId, removeSpeaker]\n        ),\n        200\n      );\n\n      const rmpAudioIds = useParticipantIds({\n        filter: useCallback(\n          (p: ExtendedDailyParticipant) => Boolean(p?.tracks?.rmpAudio),\n          []\n        ),\n      });\n\n      return (\n        <div ref={containerRef}>\n          {speakers.map((sessionId, idx) => (\n            <DailyAudioTrack\n              key={`speaker-slot-${idx}`}\n              onPlayFailed={onPlayFailed}\n              sessionId={sessionId}\n              type=\"audio\"\n            />\n          ))}\n          {screens\n            .filter((screen) => (playLocalScreenAudio ? true : !screen.local))\n            .map((screen) => (\n              <DailyAudioTrack\n                key={screen.screenId}\n                onPlayFailed={onPlayFailed}\n                sessionId={screen.session_id}\n                type=\"screenAudio\"\n              />\n            ))}\n          {rmpAudioIds.map((id) => (\n            <DailyAudioTrack\n              key={`${id}-rmp`}\n              onPlayFailed={onPlayFailed}\n              sessionId={id}\n              type=\"rmpAudio\"\n            />\n          ))}\n        </div>\n      );\n    }\n  )\n);\nDailyAudio.displayName = 'DailyAudio';\n","import React, { forwardRef, useEffect, useMemo, useRef } from 'react';\n\nimport { useLocalSessionId } from '../hooks/useLocalSessionId';\nimport { useMediaTrack } from '../hooks/useMediaTrack';\nimport useMergedRef from '../hooks/useMergedRef';\nimport { useParticipantProperty } from '../hooks/useParticipantProperty';\n\ninterface DailyVideoDimensions {\n  aspectRatio: number;\n  height: number;\n  width: number;\n}\n\ninterface Props\n  extends Omit<React.VideoHTMLAttributes<HTMLVideoElement>, 'onResize'> {\n  /**\n   * For local user-facing camera streams, we'll automatically mirror the video.\n   */\n  automirror?: boolean;\n  /**\n   * Defines whether the video should be fully contained or cover the box. Default: 'contain'.\n   */\n  fit?: 'contain' | 'cover';\n  /**\n   * Forces the video to be mirrored, if set.\n   */\n  mirror?: boolean;\n  /**\n   * Optional styles to apply, when video is playable.\n   */\n  playableStyle?: React.CSSProperties;\n  /**\n   * Optional callback, which is triggered whenever the video's rendered width or height changes.\n   * Returns the video's native width, height and aspectRatio.\n   */\n  onResize?(dimensions: DailyVideoDimensions): void;\n  /**\n   * Identifies the participant for which a video stream should be rendered.\n   */\n  sessionId: string;\n  /**\n   * Defines the track type being used.\n   */\n  type: 'video' | 'screenVideo' | 'rmpVideo';\n}\n\nexport const DailyVideo = forwardRef<HTMLVideoElement, Props>(\n  function DailyVideo(\n    {\n      automirror,\n      fit = 'contain',\n      mirror,\n      onResize,\n      playableStyle = {},\n      sessionId,\n      style = {},\n      type = 'video',\n      ...props\n    },\n    ref\n  ) {\n    const localSessionId = useLocalSessionId();\n    const isLocal = localSessionId === sessionId;\n    const isScreen = type === 'screenVideo';\n    const isLocalCam = isLocal && !isScreen;\n\n    const videoEl = useRef<HTMLVideoElement>(null);\n    const videoRef = useMergedRef<HTMLVideoElement>(videoEl, ref);\n\n    const videoState = useMediaTrack(sessionId, type);\n    const videoTrack = videoState.persistentTrack;\n    /**\n     * Considered as playable video:\n     * - local cam feed\n     * - any screen share\n     * - remote cam feed that is subscribed and reported as playable\n     */\n    const isPlayable = isLocalCam || isScreen || !videoState.isOff;\n    const trackState = useParticipantProperty(sessionId, `tracks.${type}`);\n    const subscribedState = trackState?.subscribed;\n\n    /**\n     * Determine if video needs to be mirrored.\n     */\n    const isMirrored = useMemo(() => {\n      if (typeof mirror === 'boolean') return mirror;\n      if (!automirror) return false;\n      if (!videoTrack) return isLocalCam;\n\n      const videoTrackSettings = videoTrack.getSettings();\n      const isUsersFrontCamera =\n        'facingMode' in videoTrackSettings\n          ? isLocalCam && videoTrackSettings.facingMode === 'user'\n          : isLocalCam;\n      // only apply mirror effect to user facing camera\n      return isUsersFrontCamera;\n    }, [automirror, isLocalCam, mirror, videoTrack]);\n\n    /**\n     * Handle canplay & picture-in-picture events.\n     */\n    useEffect(function setupVideoEvents() {\n      const video = videoEl.current;\n      if (!video) return;\n\n      const playVideo = () => {\n        const promise = video.play();\n        if (promise !== undefined) {\n          promise\n            .then(() => {\n              // All good, playback started.\n              video.controls = false;\n            })\n            .catch((error) => {\n              // Auto-play was prevented. Show video controls, so user can play video manually.\n              video.controls = true;\n              console.warn('Failed to play video', error);\n            });\n        }\n      };\n\n      const handleCanPlay = () => {\n        if (!video.paused) return;\n        playVideo();\n      };\n      const handleEnterPIP = () => {\n        video.style.transform = 'scale(1)';\n      };\n      const handleLeavePIP = () => {\n        video.style.transform = '';\n        setTimeout(() => {\n          if (video.paused) playVideo();\n        }, 100);\n      };\n      const handleVisibilityChange = () => {\n        if (document.visibilityState === 'hidden') return;\n        if (!video.paused) return;\n        playVideo();\n      };\n      video.addEventListener('canplay', handleCanPlay);\n      video.addEventListener('enterpictureinpicture', handleEnterPIP);\n      video.addEventListener('leavepictureinpicture', handleLeavePIP);\n\n      // Videos can be paused if media was played in another app on iOS.\n      // Resuming here, when returning back to Daily call.\n      document.addEventListener('visibilitychange', handleVisibilityChange);\n      return () => {\n        video.removeEventListener('canplay', handleCanPlay);\n        video.removeEventListener('enterpictureinpicture', handleEnterPIP);\n        video.removeEventListener('leavepictureinpicture', handleLeavePIP);\n        document.removeEventListener(\n          'visibilitychange',\n          handleVisibilityChange\n        );\n      };\n    }, []);\n\n    /**\n     * Update srcObject.\n     */\n    useEffect(\n      function updateSrcObject() {\n        const video = videoEl.current;\n        if (!video || !videoTrack) return;\n        if (!MediaStream) {\n          console.warn(\n            `MediaStream API not available. Can't setup ${type} for ${sessionId}`\n          );\n          return;\n        }\n        video.srcObject = new MediaStream([videoTrack]);\n        video.load();\n        return () => {\n          // clean up when unmounted\n          video.srcObject = null;\n          video.load();\n        };\n      },\n      [sessionId, type, videoTrack, videoTrack?.id]\n    );\n\n    /**\n     * Add optional event listener for resize event so the parent component\n     * can know the video's native aspect ratio.\n     */\n    useEffect(\n      function reportVideoDimensions() {\n        const video = videoEl.current;\n        if (!onResize || !video) return;\n\n        let frame: ReturnType<typeof requestAnimationFrame>;\n        function handleResize() {\n          if (frame) cancelAnimationFrame(frame);\n          frame = requestAnimationFrame(() => {\n            const video = videoEl.current;\n            if (!video || document.hidden) return;\n            const videoWidth = video.videoWidth;\n            const videoHeight = video.videoHeight;\n            if (videoWidth && videoHeight) {\n              onResize?.({\n                aspectRatio: videoWidth / videoHeight,\n                height: videoHeight,\n                width: videoWidth,\n              });\n            }\n          });\n        }\n\n        handleResize();\n        video.addEventListener('loadedmetadata', handleResize);\n        video.addEventListener('resize', handleResize);\n\n        return () => {\n          if (frame) cancelAnimationFrame(frame);\n          video.removeEventListener('loadedmetadata', handleResize);\n          video.removeEventListener('resize', handleResize);\n        };\n      },\n      [onResize]\n    );\n\n    return (\n      <video\n        autoPlay\n        muted\n        playsInline\n        ref={videoRef}\n        data-local={isLocal}\n        // Only set data-mirrored and data-playable when true\n        data-mirrored={isMirrored || undefined}\n        data-playable={isPlayable || undefined}\n        data-session-id={sessionId}\n        data-subscribed={subscribedState}\n        data-video-type={type}\n        style={{\n          objectFit: fit,\n          transform: isMirrored ? 'scale(-1, 1)' : '',\n          ...style,\n          ...(isPlayable ? playableStyle : {}),\n        }}\n        {...props}\n      />\n    );\n  }\n);\nDailyVideo.displayName = 'DailyVideo';\n","import { createContext } from 'react';\n\ninterface DevicesContextValue {\n  refreshDevices(): Promise<void>;\n}\n\nexport const DailyDevicesContext = createContext<DevicesContextValue>({\n  refreshDevices: () => Promise.resolve(),\n});\n","import {\n  DailyCameraErrorObject,\n  DailyCameraErrorType,\n} from '@daily-co/daily-js';\nimport { atom } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport React, { useCallback } from 'react';\n\nimport { DailyDevicesContext } from './DailyDevicesContext';\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { jotaiDebugLabel } from './lib/jotai-custom';\n\ntype GeneralState =\n  | 'idle'\n  | 'pending'\n  | 'not-supported'\n  | 'granted'\n  | 'blocked'\n  | 'in-use'\n  | 'not-found'\n  | 'constraints-invalid'\n  | 'constraints-none-specified'\n  | 'undefined-mediadevices'\n  | 'unknown';\n\ntype DeviceState = 'granted' | 'in-use';\nexport interface StatefulDevice {\n  device: MediaDeviceInfo;\n  selected: boolean;\n  state: DeviceState;\n}\n\nexport const generalCameraState = atom<GeneralState>('idle');\ngeneralCameraState.debugLabel = jotaiDebugLabel('camera-state');\nexport const generalMicrophoneState = atom<GeneralState>('idle');\ngeneralMicrophoneState.debugLabel = jotaiDebugLabel('microphone-state');\nexport const cameraDevicesState = atom<StatefulDevice[]>([]);\ncameraDevicesState.debugLabel = jotaiDebugLabel('camera-devices');\nexport const microphoneDevicesState = atom<StatefulDevice[]>([]);\nmicrophoneDevicesState.debugLabel = jotaiDebugLabel('microphone-devices');\nexport const speakerDevicesState = atom<StatefulDevice[]>([]);\nspeakerDevicesState.debugLabel = jotaiDebugLabel('speaker-devices');\nexport const lastCameraErrorState =\n  atom<DailyCameraErrorObject<DailyCameraErrorType> | null>(null);\nlastCameraErrorState.debugLabel = jotaiDebugLabel('last-camera-error');\n\nexport const DailyDevices: React.FC<React.PropsWithChildren<unknown>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n\n  /**\n   * Refreshes list of available devices using enumerateDevices.\n   * Previous device states are kept in place, otherwise states are initialized as 'granted'.\n   */\n  const refreshDevices = useAtomCallback(\n    useCallback(\n      async (_get, set) => {\n        /**\n         * Check for legacy browsers.\n         */\n        if (\n          typeof navigator?.mediaDevices?.getUserMedia === 'undefined' ||\n          typeof navigator?.mediaDevices?.enumerateDevices === 'undefined'\n        ) {\n          set(generalCameraState, 'not-supported');\n          set(generalMicrophoneState, 'not-supported');\n          return;\n        }\n\n        if (!daily) return;\n\n        try {\n          const { devices } = await daily.enumerateDevices();\n          /**\n           * Filter out \"empty\" devices for when device access has not been granted (yet).\n           */\n          const cams = devices.filter(\n            (d) => d.kind === 'videoinput' && d.deviceId !== ''\n          );\n          const mics = devices.filter(\n            (d) => d.kind === 'audioinput' && d.deviceId !== ''\n          );\n          const speakers = devices.filter(\n            (d) => d.kind === 'audiooutput' && d.deviceId !== ''\n          );\n          const { camera, mic, speaker } = await daily.getInputDevices();\n\n          const mapDevice = (\n            device: {} | MediaDeviceInfo,\n            d: MediaDeviceInfo,\n            prevDevices: StatefulDevice[]\n          ) => ({\n            device: d,\n            selected: 'deviceId' in device && d.deviceId === device.deviceId,\n            state:\n              prevDevices.find((p) => p.device.deviceId === d.deviceId)\n                ?.state ?? 'granted',\n          });\n          const sortDeviceByLabel = (a: StatefulDevice, b: StatefulDevice) => {\n            if (a.device.deviceId === 'default') return -1;\n            if (b.device.deviceId === 'default') return 1;\n            if (a.device.label < b.device.label) return -1;\n            if (a.device.label > b.device.label) return 1;\n            return 0;\n          };\n\n          set(cameraDevicesState, (prevCams) =>\n            cams\n              .filter(Boolean)\n              .map<StatefulDevice>((d) => mapDevice(camera, d, prevCams))\n              .sort(sortDeviceByLabel)\n          );\n          set(microphoneDevicesState, (prevMics) =>\n            mics\n              .filter(Boolean)\n              .map<StatefulDevice>((d) => mapDevice(mic, d, prevMics))\n              .sort(sortDeviceByLabel)\n          );\n          set(speakerDevicesState, (prevSpeakers) =>\n            speakers\n              .filter(Boolean)\n              .map<StatefulDevice>((d) => mapDevice(speaker, d, prevSpeakers))\n              .sort(sortDeviceByLabel)\n          );\n        } catch (e) {\n          set(generalCameraState, 'not-supported');\n          set(generalMicrophoneState, 'not-supported');\n        }\n      },\n      [daily]\n    )\n  );\n\n  /**\n   * Updates general and specific device states, based on blocked status.\n   */\n  const updateDeviceStates = useAtomCallback(\n    useCallback(\n      async (get, set) => {\n        if (!daily) return;\n\n        const currentCamState = get(generalCameraState);\n        const currentMicState = get(generalMicrophoneState);\n\n        const participants = daily.participants();\n        // Guard against potentially uninitialized local participant\n        if (!participants.local) return;\n\n        const { tracks } = participants.local;\n\n        let camPermissionState: PermissionState = 'prompt';\n        let micPermissionState: PermissionState = 'prompt';\n        if (navigator.permissions) {\n          try {\n            const camPermission = await navigator.permissions.query({\n              // @ts-ignore\n              name: 'camera',\n            });\n            camPermissionState = camPermission.state;\n            const micPermission = await navigator.permissions.query({\n              // @ts-ignore\n              name: 'microphone',\n            });\n            micPermissionState = micPermission.state;\n          } catch {\n            // Permissions query not available\n          }\n        }\n\n        const awaitingCamAccess =\n          camPermissionState === 'prompt' &&\n          ['idle', 'pending'].includes(currentCamState) &&\n          tracks.video.state === 'interrupted' &&\n          !tracks.video.persistentTrack;\n        const initialCamOff =\n          ['idle', 'pending'].includes(currentCamState) &&\n          !tracks.video.persistentTrack &&\n          Boolean(tracks.video.off?.byUser);\n        const awaitingMicAccess =\n          micPermissionState === 'prompt' &&\n          ['idle', 'pending'].includes(currentMicState) &&\n          tracks.audio.state === 'interrupted' &&\n          !tracks.audio.persistentTrack;\n        const initialMicOff =\n          ['idle', 'pending'].includes(currentMicState) &&\n          !tracks.audio.persistentTrack &&\n          Boolean(tracks.audio.off?.byUser);\n\n        if (tracks.audio?.blocked?.byDeviceInUse) {\n          set(generalMicrophoneState, 'in-use');\n          set(microphoneDevicesState, (mics) =>\n            mics.map<StatefulDevice>((m) =>\n              m.selected ? { ...m, state: 'in-use' } : m\n            )\n          );\n        } else if (tracks.audio?.blocked?.byDeviceMissing) {\n          set(generalMicrophoneState, 'not-found');\n        } else if (\n          tracks.audio?.blocked?.byPermissions ||\n          micPermissionState === 'denied'\n        ) {\n          set(generalMicrophoneState, 'blocked');\n        } else if (awaitingMicAccess) {\n          set(generalMicrophoneState, 'pending');\n        } else if (initialMicOff) {\n          set(generalMicrophoneState, 'idle');\n        } else {\n          set(generalMicrophoneState, 'granted');\n          set(microphoneDevicesState, (mics) =>\n            mics.map<StatefulDevice>((m) =>\n              m.selected ? { ...m, state: 'granted' } : m\n            )\n          );\n        }\n\n        if (tracks.video?.blocked?.byDeviceInUse) {\n          set(generalCameraState, 'in-use');\n          set(cameraDevicesState, (cams) =>\n            cams.map<StatefulDevice>((m) =>\n              m.selected ? { ...m, state: 'in-use' } : m\n            )\n          );\n        } else if (tracks.video?.blocked?.byDeviceMissing) {\n          set(generalCameraState, 'not-found');\n        } else if (\n          tracks.video?.blocked?.byPermissions ||\n          camPermissionState === 'denied'\n        ) {\n          set(generalCameraState, 'blocked');\n        } else if (awaitingCamAccess) {\n          set(generalCameraState, 'pending');\n        } else if (initialCamOff) {\n          set(generalCameraState, 'idle');\n        } else {\n          set(generalCameraState, 'granted');\n          set(cameraDevicesState, (cams) =>\n            cams.map<StatefulDevice>((m) =>\n              m.selected ? { ...m, state: 'granted' } : m\n            )\n          );\n        }\n        refreshDevices();\n      },\n      [daily, refreshDevices]\n    )\n  );\n\n  useDailyEvent(\n    'participant-updated',\n    useCallback(\n      (ev) => {\n        if (!ev.participant.local) return;\n        updateDeviceStates();\n      },\n      [updateDeviceStates]\n    )\n  );\n\n  useDailyEvent('available-devices-updated', refreshDevices);\n  useDailyEvent('selected-devices-updated', refreshDevices);\n\n  useDailyEvent(\n    'camera-error',\n    useAtomCallback(\n      useCallback((_get, set, ev) => {\n        set(lastCameraErrorState, ev.error);\n        switch (ev.error?.type) {\n          case 'cam-in-use':\n            set(generalCameraState, 'in-use');\n            break;\n          case 'mic-in-use':\n            set(generalMicrophoneState, 'in-use');\n            break;\n          case 'cam-mic-in-use':\n            set(generalCameraState, 'in-use');\n            set(generalMicrophoneState, 'in-use');\n            break;\n          case 'not-found':\n            if (ev.error?.missingMedia.includes('video'))\n              set(generalCameraState, 'not-found');\n            if (ev.error?.missingMedia.includes('audio'))\n              set(generalMicrophoneState, 'not-found');\n            break;\n          case 'permissions':\n            if (ev.error?.blockedMedia.includes('video'))\n              set(generalCameraState, 'blocked');\n            if (ev.error?.blockedMedia.includes('audio'))\n              set(generalMicrophoneState, 'blocked');\n            break;\n          case 'constraints':\n            if (ev.error?.reason === 'invalid') {\n              set(generalCameraState, 'constraints-invalid');\n              set(generalMicrophoneState, 'constraints-invalid');\n            } else if (ev.error?.reason === 'none-specified') {\n              set(generalCameraState, 'constraints-none-specified');\n              set(generalMicrophoneState, 'constraints-none-specified');\n            }\n            break;\n          case 'undefined-mediadevices':\n            set(generalCameraState, 'undefined-mediadevices');\n            set(generalMicrophoneState, 'undefined-mediadevices');\n            break;\n          case 'unknown':\n          default:\n            set(generalCameraState, 'unknown');\n            set(generalMicrophoneState, 'unknown');\n            break;\n        }\n      }, [])\n    )\n  );\n\n  /**\n   * Update all device state, when camera is started.\n   */\n  useDailyEvent(\n    'started-camera',\n    useAtomCallback(\n      useCallback(\n        (_get, set) => {\n          set(generalCameraState, 'granted');\n          set(generalMicrophoneState, 'granted');\n          updateDeviceStates();\n        },\n        [updateDeviceStates]\n      )\n    )\n  );\n\n  return (\n    <DailyDevicesContext.Provider value={{ refreshDevices }}>\n      {children}\n    </DailyDevicesContext.Provider>\n  );\n};\n","import { DailyStreamingLayoutConfig } from '@daily-co/daily-js';\nimport { atom } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport React, { useCallback } from 'react';\n\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { jotaiDebugLabel } from './lib/jotai-custom';\n\ninterface LiveStreamingState {\n  errorMsg?: string;\n  isLiveStreaming: boolean;\n  layout?: DailyStreamingLayoutConfig;\n}\n\nexport const liveStreamingState = atom<LiveStreamingState>({\n  errorMsg: undefined,\n  isLiveStreaming: false,\n  layout: undefined,\n});\nliveStreamingState.debugLabel = jotaiDebugLabel('live-streaming');\n\nexport const DailyLiveStreaming: React.FC<React.PropsWithChildren<unknown>> = ({\n  children,\n}) => {\n  useDailyEvent(\n    'live-streaming-started',\n    useAtomCallback(\n      useCallback((_get, set, ev) => {\n        set(liveStreamingState, {\n          isLiveStreaming: true,\n          layout: ev?.layout,\n        });\n      }, [])\n    )\n  );\n\n  useDailyEvent(\n    'live-streaming-stopped',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(liveStreamingState, (prevState) => ({\n          ...prevState,\n          isLiveStreaming: false,\n          layout: undefined,\n        }));\n      }, [])\n    )\n  );\n\n  useDailyEvent(\n    'live-streaming-error',\n    useAtomCallback(\n      useCallback((_get, set, ev) => {\n        set(liveStreamingState, (prevState: LiveStreamingState) => ({\n          ...prevState,\n          errorMsg: ev.errorMsg,\n        }));\n      }, [])\n    )\n  );\n\n  useDailyEvent(\n    'left-meeting',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(liveStreamingState, {\n          errorMsg: undefined,\n          isLiveStreaming: false,\n          layout: undefined,\n        });\n      }, [])\n    )\n  );\n\n  return <>{children}</>;\n};\n","import {\n  DailyEventObjectFatalError,\n  DailyEventObjectNonFatalError,\n  DailyMeetingSessionState,\n  DailyMeetingState,\n} from '@daily-co/daily-js';\nimport { atom } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport React, { useCallback } from 'react';\n\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { jotaiDebugLabel } from './lib/jotai-custom';\n\nexport const meetingStateState = atom<DailyMeetingState>('new');\nmeetingStateState.debugLabel = jotaiDebugLabel('meeting-state');\n\nexport const meetingErrorState = atom<DailyEventObjectFatalError | null>(null);\nmeetingErrorState.debugLabel = jotaiDebugLabel('meeting-error');\n\nexport const nonFatalErrorState = atom<DailyEventObjectNonFatalError | null>(\n  null\n);\nnonFatalErrorState.debugLabel = jotaiDebugLabel('non-fatal-error');\n\nexport const meetingSessionDataState = atom<DailyMeetingSessionState>({\n  data: undefined,\n  topology: 'none',\n});\nmeetingSessionDataState.debugLabel = jotaiDebugLabel('meeting-session-data');\n\nexport const DailyMeeting: React.FC<React.PropsWithChildren<{}>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n\n  /**\n   * Updates meeting state.\n   */\n  const updateMeetingState = useAtomCallback(\n    useCallback(\n      (_get, set) => {\n        if (!daily) return;\n        const meetingState = daily.meetingState();\n        set(meetingStateState, meetingState);\n        return meetingState;\n      },\n      [daily]\n    )\n  );\n\n  useDailyEvent('loading', updateMeetingState);\n  useDailyEvent('loaded', updateMeetingState);\n  useDailyEvent('joining-meeting', updateMeetingState);\n  useDailyEvent('joined-meeting', updateMeetingState);\n  useDailyEvent('left-meeting', updateMeetingState);\n  useDailyEvent(\n    'error',\n    useAtomCallback(\n      useCallback(\n        (_get, set, ev) => {\n          set(meetingErrorState, ev);\n          updateMeetingState();\n        },\n        [updateMeetingState]\n      )\n    )\n  );\n  useDailyEvent(\n    'nonfatal-error',\n    useAtomCallback(\n      useCallback((_get, set, ev) => {\n        set(nonFatalErrorState, ev);\n      }, [])\n    )\n  );\n\n  /**\n   * Updates meeting session state.\n   */\n  const initMeetingSessionState = useAtomCallback(\n    useCallback(\n      (_get, set) => {\n        if (!daily) return;\n        set(meetingSessionDataState, daily.meetingSessionState());\n      },\n      [daily]\n    )\n  );\n\n  /**\n   * Initialize state when joined meeting or setting up the hook.\n   */\n  useDailyEvent('joined-meeting', initMeetingSessionState);\n\n  /**\n   * Update Jotai state whenever meeting session state is updated.\n   */\n  useDailyEvent(\n    'meeting-session-state-updated',\n    useAtomCallback(\n      useCallback((_get, set, ev) => {\n        set(meetingSessionDataState, ev.meetingSessionState);\n      }, [])\n    )\n  );\n\n  /**\n   * Reset Jotai state when meeting ends.\n   */\n  useDailyEvent(\n    'left-meeting',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(meetingSessionDataState, {\n          data: undefined,\n          topology: 'none',\n        });\n      }, [])\n    )\n  );\n\n  /**\n   * Reset Jotai state when call instance is destroyed.\n   */\n  useDailyEvent(\n    'call-instance-destroyed',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(meetingStateState, 'new');\n        set(meetingErrorState, null);\n        set(nonFatalErrorState, null);\n        set(meetingSessionDataState, {\n          data: undefined,\n          topology: 'none',\n        });\n      }, [])\n    )\n  );\n\n  return <>{children}</>;\n};\n","import { DailyNetworkStats, DailyNetworkTopology } from '@daily-co/daily-js';\nimport { atom, useAtomValue } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport React, { useCallback, useEffect } from 'react';\n\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { jotaiDebugLabel } from './lib/jotai-custom';\n\nexport const topologyState = atom<DailyNetworkTopology | 'none'>('none');\ntopologyState.debugLabel = jotaiDebugLabel('topology');\nexport const networkQualityState = atom<DailyNetworkStats['quality']>(100);\nnetworkQualityState.debugLabel = jotaiDebugLabel('network-quality');\nexport const networkThresholdState =\n  atom<DailyNetworkStats['threshold']>('good');\nnetworkThresholdState.debugLabel = jotaiDebugLabel('network-threshold');\n\nexport const DailyNetwork: React.FC<React.PropsWithChildren<{}>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n\n  const topology = useAtomValue(topologyState);\n\n  const initTopology = useAtomCallback(\n    useCallback(\n      async (_get, set) => {\n        if (!daily) return;\n        const topology = await daily.getNetworkTopology();\n        if (!topology || topology?.topology === 'none') return;\n        set(topologyState, topology.topology);\n      },\n      [daily]\n    )\n  );\n\n  useDailyEvent('joined-meeting', initTopology);\n  useDailyEvent(\n    'network-connection',\n    useAtomCallback(\n      useCallback((_get, set, ev) => {\n        switch (ev.event) {\n          case 'connected':\n            if (ev.type === 'peer-to-peer') set(topologyState, 'peer');\n            if (ev.type === 'sfu') set(topologyState, 'sfu');\n            break;\n        }\n      }, [])\n    )\n  );\n  useDailyEvent(\n    'network-quality-change',\n    useAtomCallback(\n      useCallback((_get, set, ev) => {\n        set(networkQualityState, (prevQuality: DailyNetworkStats['quality']) =>\n          prevQuality !== ev.quality ? ev.quality : prevQuality\n        );\n        set(\n          networkThresholdState,\n          (prevThreshold: DailyNetworkStats['threshold']) =>\n            prevThreshold !== ev.threshold ? ev.threshold : prevThreshold\n        );\n      }, [])\n    )\n  );\n\n  useDailyEvent(\n    'left-meeting',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(topologyState, 'none');\n        set(networkQualityState, 100);\n        set(networkThresholdState, 'good');\n      }, [])\n    )\n  );\n\n  useEffect(() => {\n    if (!daily || topology !== 'none') return;\n    initTopology();\n  }, [daily, initTopology, topology]);\n\n  return <>{children}</>;\n};\n","import { DailyStreamingLayoutConfig } from '@daily-co/daily-js';\nimport { atom } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport React, { useCallback, useEffect } from 'react';\n\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { useLocalSessionId } from './hooks/useLocalSessionId';\nimport { useParticipantIds } from './hooks/useParticipantIds';\nimport { customDeepEqual } from './lib/customDeepEqual';\nimport { jotaiDebugLabel } from './lib/jotai-custom';\n\ninterface RecordingState {\n  /**\n   * Determines whether an error occurred during the last recording attempt.\n   */\n  error?: boolean;\n  /**\n   * Determines whether the local participant is being recorded, based on the recording settings.\n   */\n  isLocalParticipantRecorded: boolean;\n  /**\n   * Determines whether a recording is currently running or not.\n   */\n  isRecording: boolean;\n  /**\n   * Contains the last applied cloud recording layout config.\n   */\n  layout?: DailyStreamingLayoutConfig;\n  /**\n   * Determines whether the recording is running locally.\n   * See [enable_recording](https://docs.daily.co/reference/rest-api/rooms/config#enable_recording).\n   */\n  local?: boolean;\n  /**\n   * Contains the recording id.\n   */\n  recordingId?: string;\n  /**\n   * Contains the date when the 'recording-started' event was received.\n   * This doesn't necessarily match the date the recording was actually started.\n   */\n  recordingStartedDate?: Date;\n  /**\n   * Contains the session_id of the participant who started the recording.\n   */\n  startedBy?: string;\n  /**\n   * Contains the recording type.\n   * See [enable_recording](https://docs.daily.co/reference/rest-api/rooms/config#enable_recording).\n   */\n  type?: string;\n}\n\nexport const recordingState = atom<RecordingState>({\n  isLocalParticipantRecorded: false,\n  isRecording: false,\n});\nrecordingState.debugLabel = jotaiDebugLabel('recording-state');\n\nexport const DailyRecordings: React.FC<React.PropsWithChildren<unknown>> = ({\n  children,\n}) => {\n  const localSessionId = useLocalSessionId();\n\n  const recordingParticipantIds = useParticipantIds({\n    filter: 'record',\n  });\n\n  const maybeUpdateRecordingState = useAtomCallback(\n    useCallback(\n      (\n        get,\n        set,\n        hasRecordingParticipants: boolean,\n        isLocalParticipantRecording: boolean\n      ) => {\n        const oldState = get(recordingState);\n        const s: RecordingState = {\n          isLocalParticipantRecorded: oldState.isLocalParticipantRecorded,\n          isRecording: oldState.isRecording,\n          local: oldState.local,\n          type: oldState.type,\n        };\n        const newState: RecordingState = {\n          // In case type is local or not set, determine based on recording participants\n          isLocalParticipantRecorded:\n            s?.type === 'local' || !s?.type\n              ? hasRecordingParticipants\n              : s.isLocalParticipantRecorded,\n          isRecording:\n            s?.type === 'local' || !s?.type\n              ? hasRecordingParticipants\n              : s.isRecording,\n          local:\n            (s?.type === 'local' || !s?.type) && hasRecordingParticipants\n              ? isLocalParticipantRecording\n              : s?.local,\n          /**\n           * Set type in case recording participants are detected.\n           * We only set `record` on participants, when recording type is 'local'.\n           */\n          type: hasRecordingParticipants ? 'local' : oldState?.type,\n        };\n\n        if (customDeepEqual(s, newState)) return;\n        set(recordingState, {\n          ...s,\n          ...newState,\n        });\n      },\n      []\n    )\n  );\n\n  /**\n   * Update recording state, whenever amount of recording participants changes.\n   */\n  useEffect(() => {\n    const hasRecordingParticipants = recordingParticipantIds.length > 0;\n    const isLocalParticipantRecording = recordingParticipantIds.includes(\n      localSessionId || 'local'\n    );\n    maybeUpdateRecordingState(\n      hasRecordingParticipants,\n      isLocalParticipantRecording\n    );\n  }, [localSessionId, maybeUpdateRecordingState, recordingParticipantIds]);\n\n  useDailyEvent(\n    'recording-started',\n    useAtomCallback(\n      useCallback(\n        (_get, set, ev) => {\n          let isLocalParticipantRecorded = true;\n          switch (ev.type) {\n            case 'cloud-beta':\n            case 'cloud': {\n              if (\n                localSessionId &&\n                ev.layout?.preset === 'single-participant' &&\n                ev.layout.session_id !== localSessionId\n              ) {\n                isLocalParticipantRecorded = false;\n              }\n              break;\n            }\n          }\n          set(recordingState, {\n            error: false,\n            isLocalParticipantRecorded,\n            isRecording: true,\n            layout: ev?.layout,\n            local: ev?.local,\n            recordingId: ev?.recordingId,\n            recordingStartedDate: new Date(),\n            startedBy: ev?.startedBy,\n            type: ev?.type,\n          });\n        },\n        [localSessionId]\n      )\n    )\n  );\n  useDailyEvent(\n    'recording-stopped',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(recordingState, (prevState) => ({\n          ...prevState,\n          isLocalParticipantRecorded: false,\n          isRecording: false,\n        }));\n      }, [])\n    )\n  );\n  useDailyEvent(\n    'recording-error',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(recordingState, (prevState: RecordingState) => ({\n          ...prevState,\n          error: true,\n          isLocalParticipantRecorded: false,\n          isRecording: false,\n        }));\n      }, [])\n    )\n  );\n  useDailyEvent(\n    'left-meeting',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(recordingState, {\n          isLocalParticipantRecorded: false,\n          isRecording: false,\n        });\n      }, [])\n    )\n  );\n  return <>{children}</>;\n};\n","import { DailyMeetingState } from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useDebugValue } from 'react';\n\nimport { meetingStateState } from '../DailyMeeting';\n\n/**\n * Returns a meeting's current state.\n */\nexport const useMeetingState = (): DailyMeetingState | null => {\n  const meetingState = useAtomValue(meetingStateState);\n  useDebugValue(meetingState);\n  return meetingState;\n};\n","import { DailyRoomInfo } from '@daily-co/daily-js';\nimport { atom } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport React, { useCallback } from 'react';\n\nimport { useDaily } from './hooks/useDaily';\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { useMeetingState } from './hooks/useMeetingState';\nimport { jotaiDebugLabel } from './lib/jotai-custom';\n\nexport const roomState = atom<DailyRoomInfo | null>(null);\nroomState.debugLabel = jotaiDebugLabel('room-state');\n\nexport const DailyRoom: React.FC<React.PropsWithChildren<{}>> = ({\n  children,\n}) => {\n  const daily = useDaily();\n  const meetingState = useMeetingState();\n\n  const updateRoom = useAtomCallback(\n    useCallback(\n      async (_get, set) => {\n        if (!daily || meetingState === 'left-meeting') return;\n        const room = await daily.room();\n        if (room && 'id' in room) {\n          set(roomState, room);\n        }\n        return room;\n      },\n      [daily, meetingState]\n    )\n  );\n\n  useDailyEvent('access-state-updated', updateRoom);\n\n  useDailyEvent(\n    'left-meeting',\n    useAtomCallback(\n      useCallback(\n        (_get, set) => () => {\n          set(roomState, null);\n        },\n        []\n      )\n    )\n  );\n\n  return <>{children}</>;\n};\n","import {\n  DailyEventObjectAppMessage,\n  DailyTranscriptionDeepgramOptions,\n} from '@daily-co/daily-js';\nimport { atom } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport React, { useCallback } from 'react';\n\nimport { useDailyEvent } from './hooks/useDailyEvent';\nimport { jotaiDebugLabel } from './lib/jotai-custom';\n\nexport interface Transcription {\n  session_id: string;\n  user_id: string;\n  text: string;\n  timestamp: string;\n  // Deprecated\n  is_final: boolean;\n}\n\ninterface TranscriptionState extends DailyTranscriptionDeepgramOptions {\n  /**\n   * Determines whether an error occurred during the last transcription attempt.\n   */\n  error?: boolean;\n  /**\n   * Determines whether a transcription is currently running or not.\n   */\n  isTranscribing: boolean;\n  /**\n   * Contains the date when the 'transcription-started' event was received.\n   * This doesn't necessarily match the date the transcription was actually started.\n   */\n  transcriptionStartDate?: Date;\n  /**\n   * Contains the session_id of the participant who started the transcription.\n   */\n  startedBy?: string;\n  /**\n   * Contains the session_id of the participant who updated the transcription.\n   */\n  updatedBy?: string;\n  /**\n   * Contains the transcriptions that we received.\n   */\n  transcriptions: Transcription[];\n}\n\nexport const transcriptionState = atom<TranscriptionState>({\n  isTranscribing: false,\n  model: 'general',\n  language: 'en',\n  transcriptions: [],\n});\ntranscriptionState.debugLabel = jotaiDebugLabel('transcription-state');\n\nexport const DailyTranscriptions: React.FC<React.PropsWithChildren<{}>> = ({\n  children,\n}) => {\n  useDailyEvent(\n    'transcription-started',\n    useAtomCallback(\n      useCallback((_get, set, ev) => {\n        set(transcriptionState, {\n          error: false,\n          transcriptionStartDate: new Date(),\n          isTranscribing: true,\n          transcriptions: [],\n          endpointing: ev.endpointing,\n          extra: ev.extra,\n          includeRawResponse: ev.includeRawResponse,\n          instanceId: ev.instanceId,\n          language: ev.language,\n          model: ev.model,\n          profanity_filter: ev.profanity_filter,\n          punctuate: ev.punctuate,\n          redact: ev.redact,\n          startedBy: ev.startedBy,\n          tier: ev.tier,\n        });\n      }, [])\n    )\n  );\n  useDailyEvent(\n    'transcription-stopped',\n    useAtomCallback(\n      useCallback((_get, set, ev) => {\n        set(transcriptionState, (prevState: TranscriptionState) => ({\n          ...prevState,\n          updatedBy: ev.updatedBy,\n          isTranscribing: false,\n        }));\n      }, [])\n    )\n  );\n  useDailyEvent(\n    'transcription-error',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(transcriptionState, (prevState) => ({\n          ...prevState,\n          error: true,\n          isTranscribing: false,\n        }));\n      }, [])\n    )\n  );\n  useDailyEvent(\n    'left-meeting',\n    useAtomCallback(\n      useCallback((_get, set) => {\n        set(transcriptionState, (prevState) => ({\n          ...prevState,\n          isTranscribing: false,\n        }));\n      }, [])\n    )\n  );\n  useDailyEvent(\n    'app-message',\n    useAtomCallback(\n      useCallback(\n        (_get, set, ev: DailyEventObjectAppMessage<Transcription>) => {\n          if (ev?.fromId === 'transcription') {\n            set(transcriptionState, (prevState) => ({\n              ...prevState,\n              // setting it to true whenever a new message is received\n              // as the participants who joined after the transcription-started event\n              // won't be knowing if transcription is started or not\n              isTranscribing: true,\n              transcriptions: [...prevState.transcriptions, ev.data],\n            }));\n          }\n        },\n        []\n      )\n    )\n  );\n\n  return <>{children}</>;\n};\n","import Daily, { DailyCall, DailyFactoryOptions } from '@daily-co/daily-js';\nimport { MutableRefObject, useEffect, useRef, useState } from 'react';\n\nimport { customDeepEqual } from '../lib/customDeepEqual';\n\ntype InstanceType = 'callFrame' | 'callObject';\n\nconst defaultOptions: DailyFactoryOptions = {};\nconst defaultShouldCreateInstance = () => true;\n\nexport interface Props {\n  parentElRef?: MutableRefObject<HTMLElement>;\n  options?: DailyFactoryOptions;\n  shouldCreateInstance?(): boolean;\n}\n\nconst defaultProps: Props = {\n  options: defaultOptions,\n  shouldCreateInstance: defaultShouldCreateInstance,\n};\n\n/**\n * Helper hook to maintain custom call instances in React codebases.\n */\nexport const useCallInstance = (\n  type: InstanceType,\n  {\n    parentElRef,\n    options = defaultOptions,\n    shouldCreateInstance = defaultShouldCreateInstance,\n  }: Props = defaultProps\n) => {\n  const [callInstance, setCallInstance] = useState<DailyCall | null>(null);\n\n  /**\n   * Holds last used props when callObject instance was created.\n   */\n  const lastUsedOptions = useRef<DailyFactoryOptions>();\n  useEffect(() => {\n    /**\n     * Call frame instances with a defined parentEl likely pass a ref.\n     * Typically a DOM ref is initialized with useRef(null).\n     * We'll want to wait until parentEl is defined, meaning that the ref is\n     * correctly wired up with a DOM element.\n     * Otherwise we'll just check shouldCreateInstance().\n     */\n    if (\n      (type === 'callFrame' && parentElRef?.current === null) ||\n      !shouldCreateInstance()\n    )\n      return;\n\n    async function destroyCallInstance(co: DailyCall) {\n      await co.destroy();\n    }\n\n    /**\n     * Once instance is destroyed, nullify callInstance, so a new one can be created.\n     */\n    const handleDestroyedInstance = () => {\n      /**\n       * Setting a timeout makes sure the destruction and creation\n       * of call instances happen in separate call stacks.\n       * Otherwise there's a risk for duplicate call instances.\n       */\n      setTimeout(() => setCallInstance(null), 0);\n    };\n\n    let co = Daily.getCallInstance();\n\n    /**\n     * In case a call instance exists outside of this hook instance's knowledge,\n     * store it in state.\n     */\n    if (!callInstance && co && !co.isDestroyed()) {\n      co.once('call-instance-destroyed', handleDestroyedInstance);\n      setCallInstance(co);\n      return;\n    }\n\n    /**\n     * callInstance exists.\n     */\n    if (callInstance) {\n      /**\n       * Props have changed. Destroy current instance, so a new one can be created.\n       */\n      if (!customDeepEqual(lastUsedOptions.current, options)) {\n        destroyCallInstance(callInstance);\n      }\n      /**\n       * Return early.\n       */\n      return;\n    }\n\n    if (!co || co.isDestroyed()) {\n      /**\n       * callInstance doesn't exist or is destroyed (TODO: Check why getCallInstance() can return a destroyed instance),\n       * but should be created.\n       * Important to spread props, because createCallObject/createFrame alters the passed object (adds layout and dailyJsVersion).\n       */\n      switch (type) {\n        case 'callFrame':\n          co = parentElRef?.current\n            ? Daily.createFrame(parentElRef.current, { ...options })\n            : Daily.createFrame({ ...options });\n          break;\n        case 'callObject':\n          co = Daily.createCallObject({ ...options });\n          break;\n      }\n      lastUsedOptions.current = options;\n    }\n\n    setCallInstance(co);\n\n    co.once('call-instance-destroyed', handleDestroyedInstance);\n\n    /**\n     * No cleanup phase here, because callObject.destroy() returns a Promise.\n     * We can't have asynchronous cleanups in a useEffect.\n     * To avoid infinite render loops we compare the props when creating call object instances.\n     */\n  }, [callInstance, options, parentElRef, shouldCreateInstance, type]);\n\n  return callInstance;\n};\n","import { Props, useCallInstance } from './useCallInstance';\n\ntype CallObjectProps = Omit<Props, 'parentEl'>;\n\n/**\n * Helper hook to maintain custom callObject instances in React codebases.\n */\nexport const useCallObject = (props: CallObjectProps) =>\n  useCallInstance('callObject', props);\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useCallback, useDebugValue } from 'react';\n\nimport { participantState } from '../DailyParticipants';\nimport { useThrottledDailyEvent } from './useThrottledDailyEvent';\n\ninterface UseParticipantArgs {\n  onParticipantLeft?(ev: DailyEventObject<'participant-left'>): void;\n  onParticipantUpdated?(ev: DailyEventObject<'participant-updated'>): void;\n}\n\n/**\n * Returns the participant identified by the given sessionId.\n * @param sessionId  The participant's session_id or \"local\".\n * @deprecated Use [useParticipantProperty](https://docs.daily.co/reference/daily-react/use-participant-property) instead to only subscribe to required participant properties.\n */\nexport const useParticipant = (\n  sessionId: string,\n  { onParticipantLeft, onParticipantUpdated }: UseParticipantArgs = {}\n) => {\n  const participant = useAtomValue(participantState(sessionId));\n\n  useThrottledDailyEvent(\n    ['participant-updated', 'participant-left'],\n    useCallback(\n      (evts) => {\n        const filteredEvts = evts.filter(\n          (ev) => ev.participant.session_id === sessionId\n        );\n        if (!filteredEvts.length) return;\n        filteredEvts.forEach((ev) => {\n          switch (ev.action) {\n            case 'participant-updated':\n              onParticipantUpdated?.(ev);\n              break;\n            case 'participant-left':\n              onParticipantLeft?.(ev);\n              break;\n          }\n        });\n      },\n      [onParticipantLeft, onParticipantUpdated, sessionId]\n    )\n  );\n\n  useDebugValue(participant);\n\n  return participant;\n};\n","const audioLevelProcessor = `\n    class AudioLevelProcessor extends AudioWorkletProcessor {\n    volume;\n    interval;\n    nextFrame;\n    \n    constructor() {\n      super();\n      this.volume = 0;\n      this.interval = 25;\n      this.nextFrame = this.interval;\n    }\n    \n    get intervalInFrames() {\n      // sampleRate is globally defined in AudioWorklets.\n      // See https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletGlobalScope\n      // eslint-disable-next-line no-undef\n      return (this.interval / 1000) * sampleRate;\n    }\n    \n    process(inputList) {\n      const firstInput = inputList[0];\n    \n      if (firstInput.length > 0) {\n        const inputData = firstInput[0];\n        let total = 0;\n    \n        for (let i = 0; i < inputData.length; ++i) {\n          total += Math.abs(inputData[i]);\n        }\n    \n        const rms = Math.sqrt(total / inputData.length);\n        this.volume = Math.max(0, Math.min(1, rms));\n    \n        this.nextFrame -= inputData.length;\n        if (this.nextFrame < 0) {\n          this.nextFrame += this.intervalInFrames;\n          this.port.postMessage({ volume: this.volume });\n        }\n      }\n    \n      return true;\n    }\n    }\n    \n    registerProcessor('audiolevel', AudioLevelProcessor);              \n`;\n\nexport const inlineAudioWorklet = `data:application/javascript;charset=utf8,${encodeURIComponent(\n  audioLevelProcessor\n)}`;\n","import { DailyCpuLoadStats, DailyEventObject } from '@daily-co/daily-js';\nimport deepEqual from 'fast-deep-equal';\nimport { atom, useAtomValue } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport { useCallback, useDebugValue, useEffect } from 'react';\n\nimport { jotaiDebugLabel } from '../lib/jotai-custom';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\nimport { useMeetingState } from './useMeetingState';\n\ninterface CPULoad {\n  state: DailyCpuLoadStats['cpuLoadState'];\n  reason: DailyCpuLoadStats['cpuLoadStateReason'];\n}\n\nconst CPULoadState = atom<CPULoad>({\n  state: 'low',\n  reason: 'none',\n});\nCPULoadState.debugLabel = jotaiDebugLabel('cpu-load');\n\ninterface Props {\n  onCPULoadChange?(ev: DailyEventObject<'cpu-load-change'>): void;\n}\n\n/**\n * Returns the current CPU load as reported by daily-js [cpu-load-change](https://docs.daily.co/reference/daily-js/events/quality-events#cpu-load-change) events\n * and [getCpuLoadStats](https://docs.daily.co/reference/daily-js/instance-methods/get-cpu-load-stats).\n */\nexport const useCPULoad = ({ onCPULoadChange }: Props = {}) => {\n  const cpu = useAtomValue(CPULoadState);\n  const daily = useDaily();\n  const meetingState = useMeetingState();\n\n  const updateCPULoadState = useAtomCallback(\n    useCallback((get, set, cpu: CPULoad) => {\n      const prev = get(CPULoadState); // Get the current CPU load state\n      if (deepEqual(prev, cpu)) return; // Check if the previous state is equal to the current one\n      set(CPULoadState, cpu); // Update the state if different\n    }, [])\n  );\n\n  useEffect(() => {\n    let mounted = true;\n    if (!daily || daily.isDestroyed() || meetingState !== 'joined-meeting')\n      return;\n    daily.getCpuLoadStats().then((stats) => {\n      if (!mounted) return;\n      updateCPULoadState({\n        state: stats.cpuLoadState,\n        reason: stats.cpuLoadStateReason,\n      });\n    });\n    return () => {\n      mounted = false;\n    };\n  }, [daily, meetingState, updateCPULoadState]);\n\n  useDailyEvent(\n    'cpu-load-change',\n    useCallback(\n      (ev) => {\n        updateCPULoadState({\n          state: ev.cpuLoadState,\n          reason: ev.cpuLoadStateReason,\n        });\n        onCPULoadChange?.(ev);\n      },\n      [onCPULoadChange, updateCPULoadState]\n    )\n  );\n\n  useDebugValue(cpu);\n\n  return cpu;\n};\n","import { useAtomValue } from 'jotai';\nimport { useDebugValue } from 'react';\n\nimport { meetingErrorState, nonFatalErrorState } from '../DailyMeeting';\n\n/**\n * Returns a meeting's last known errors.\n */\nexport const useDailyError = () => {\n  const meetingError = useAtomValue(meetingErrorState);\n  const nonFatalError = useAtomValue(nonFatalErrorState);\n  const result = {\n    meetingError,\n    nonFatalError,\n  };\n  useDebugValue(result);\n  return result;\n};\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailyEventObjectNonFatalError,\n  DailyInputSettings,\n} from '@daily-co/daily-js';\nimport { atom, useAtomValue } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport { useCallback, useDebugValue, useEffect } from 'react';\n\nimport { jotaiDebugLabel } from '../lib/jotai-custom';\nimport { Reconstruct } from '../types/Reconstruct';\nimport { useDaily } from './useDaily';\nimport { useDailyError } from './useDailyError';\nimport { useDailyEvent } from './useDailyEvent';\n\ntype DailyEventObjectInputSettingsError = Reconstruct<\n  DailyEventObjectNonFatalError,\n  'type',\n  'input-settings-error'\n>;\n\ninterface UseInputSettingsArgs {\n  onError?(ev: DailyEventObjectInputSettingsError): void;\n  onInputSettingsUpdated?(ev: DailyEventObject<'input-settings-updated'>): void;\n}\n\nconst inputSettingsState = atom<DailyInputSettings | null>(null);\ninputSettingsState.debugLabel = jotaiDebugLabel('input-settings');\n\nexport const useInputSettings = ({\n  onError,\n  onInputSettingsUpdated,\n}: UseInputSettingsArgs = {}) => {\n  const inputSettings = useAtomValue(inputSettingsState);\n  const { nonFatalError } = useDailyError();\n  const daily = useDaily();\n\n  const updateInputSettingsState = useAtomCallback(\n    useCallback((_get, set, inputSettings: DailyInputSettings) => {\n      set(inputSettingsState, inputSettings);\n    }, [])\n  );\n\n  useEffect(() => {\n    if (!daily) return;\n    daily.getInputSettings().then(updateInputSettingsState);\n  }, [daily, updateInputSettingsState]);\n\n  /**\n   * Handle 'input-settings-updated' events.\n   */\n  useDailyEvent(\n    'input-settings-updated',\n    useCallback(\n      (ev) => {\n        updateInputSettingsState(ev.inputSettings);\n        onInputSettingsUpdated?.(ev);\n      },\n      [onInputSettingsUpdated, updateInputSettingsState]\n    )\n  );\n\n  /**\n   * Handle nonfatal errors of type 'input-settings-error'.\n   */\n  useDailyEvent(\n    'nonfatal-error',\n    useCallback(\n      (ev) => {\n        if (ev.type !== 'input-settings-error') return;\n        onError?.(ev as DailyEventObjectInputSettingsError);\n      },\n      [onError]\n    )\n  );\n\n  /**\n   * Calls daily.updateInputSettings internally.\n   */\n  const updateInputSettings = useCallback(\n    (...args: Parameters<DailyCall['updateInputSettings']>) => {\n      return daily?.updateInputSettings(...args);\n    },\n    [daily]\n  );\n\n  const result = {\n    errorMsg:\n      nonFatalError?.type === 'input-settings-error'\n        ? nonFatalError.errorMsg\n        : null,\n    inputSettings,\n    updateInputSettings,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyEventObject, DailyParticipantCounts } from '@daily-co/daily-js';\nimport { atom, useAtomValue } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport { useCallback, useDebugValue, useEffect } from 'react';\n\nimport { jotaiDebugLabel } from '../lib/jotai-custom';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\nconst participantCountsState = atom<DailyParticipantCounts>({\n  hidden: 0,\n  present: 0,\n});\nparticipantCountsState.debugLabel = jotaiDebugLabel('participant-counts');\n\ninterface Props {\n  onParticipantCountsUpdated?(\n    ev: DailyEventObject<'participant-counts-updated'>\n  ): void;\n}\n\n/**\n * Returns participant counts for hidden and present participants.\n */\nexport const useParticipantCounts = ({\n  onParticipantCountsUpdated,\n}: Props = {}) => {\n  const daily = useDaily();\n  const participantCounts = useAtomValue(participantCountsState);\n\n  const updateCounts = useAtomCallback(\n    useCallback((_get, set, counts: DailyParticipantCounts) => {\n      set(participantCountsState, counts);\n    }, [])\n  );\n\n  useDailyEvent(\n    'participant-counts-updated',\n    useCallback(\n      (ev) => {\n        updateCounts(ev.participantCounts);\n        onParticipantCountsUpdated?.(ev);\n      },\n      [onParticipantCountsUpdated, updateCounts]\n    )\n  );\n\n  useEffect(() => {\n    if (!daily || daily.isDestroyed()) return;\n    updateCounts(daily.participantCounts());\n  }, [daily, updateCounts]);\n\n  useDebugValue(participantCounts);\n\n  return participantCounts;\n};\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailyReceiveSettings,\n  DailySingleParticipantReceiveSettings,\n} from '@daily-co/daily-js';\nimport { atom, Getter, Setter, useAtom, WritableAtom } from 'jotai';\nimport { useAtomCallback } from 'jotai/utils';\nimport { atomFamily } from 'jotai/utils';\nimport { useCallback, useDebugValue, useEffect } from 'react';\n\nimport { jotaiDebugLabel } from '../lib/jotai-custom';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\nimport { useMeetingState } from './useMeetingState';\n\nconst participantReceiveSettingsState = atomFamily<\n  string,\n  WritableAtom<\n    DailySingleParticipantReceiveSettings,\n    [DailySingleParticipantReceiveSettings],\n    void\n  >\n>((id) => {\n  const participantReceiveSettingsAtom = atom<\n    DailySingleParticipantReceiveSettings,\n    [DailySingleParticipantReceiveSettings],\n    void\n  >({}, (_get, set, newValue) => {\n    set(participantReceiveSettingsState(id), newValue);\n  });\n  participantReceiveSettingsAtom.debugLabel = jotaiDebugLabel(\n    `participant-receive-settings-${id}`\n  );\n  return participantReceiveSettingsAtom;\n});\n\ninterface UseReceiveSettingsArgs {\n  id?: string;\n  onReceiveSettingsUpdated?(\n    ev: DailyEventObject<'receive-settings-updated'>\n  ): void;\n}\n\n/**\n * Allows to read and set receiveSettings.\n * In case receiveSettings for participant specified by id are empty, not set or 'inherit',\n * base receiveSettings will be returned.\n * In case meeting is not in joined state, calls to updateReceiveSettings will be silently ignored.\n */\nexport const useReceiveSettings = ({\n  id = 'base',\n  onReceiveSettingsUpdated,\n}: UseReceiveSettingsArgs = {}) => {\n  const [baseSettings] = useAtom(participantReceiveSettingsState('base'));\n  const [receiveSettings] = useAtom(participantReceiveSettingsState(id));\n  const daily = useDaily();\n  const meetingState = useMeetingState();\n\n  const updateReceiveSettingsState = useAtomCallback(\n    useCallback(\n      (_get: Getter, set: Setter, receiveSettings: DailyReceiveSettings) => {\n        const { ...ids } = receiveSettings;\n        for (let [id, settings] of Object.entries(ids)) {\n          set(participantReceiveSettingsState(id), settings);\n        }\n        if (!(id in ids)) {\n          participantReceiveSettingsState.remove(id);\n        }\n      },\n      [id] // Dependencies\n    )\n  );\n\n  useDailyEvent(\n    'receive-settings-updated',\n    useCallback(\n      (ev) => {\n        updateReceiveSettingsState(ev.receiveSettings);\n        onReceiveSettingsUpdated?.(ev);\n      },\n      [onReceiveSettingsUpdated, updateReceiveSettingsState]\n    )\n  );\n\n  useEffect(() => {\n    if (!daily || daily.isDestroyed()) return;\n    daily.getReceiveSettings().then(updateReceiveSettingsState);\n  }, [daily, updateReceiveSettingsState]);\n\n  const updateReceiveSettings = useCallback(\n    (...args: Parameters<DailyCall['updateReceiveSettings']>) => {\n      if (!daily || meetingState !== 'joined-meeting') return;\n      daily?.updateReceiveSettings?.(...args);\n    },\n    [daily, meetingState]\n  );\n\n  const result = {\n    receiveSettings:\n      id === 'base' || Object.keys(receiveSettings).length === 0\n        ? baseSettings\n        : receiveSettings,\n    updateReceiveSettings,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyRoomInfo } from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useDebugValue } from 'react';\n\nimport { roomState } from '../DailyRoom';\n\n/**\n * Stateful hook to work with room, domain and token configuration for a daily room.\n * Includes room default values.\n */\nexport const useRoom = (): DailyRoomInfo | null => {\n  const room = useAtomValue(roomState);\n  useDebugValue(room);\n  return room;\n};\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailySendSettings,\n} from '@daily-co/daily-js';\nimport { atom, useAtom } from 'jotai';\nimport { useCallback, useDebugValue, useEffect } from 'react';\n\nimport { jotaiDebugLabel } from '../lib/jotai-custom';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\nconst sendSettingsState = atom<DailySendSettings | null>(null);\nsendSettingsState.debugLabel = jotaiDebugLabel('send-settings');\n\ninterface Props {\n  onSendSettingsUpdated?(ev: DailyEventObject<'send-settings-updated'>): void;\n}\n\n/**\n * Returns the current media send settings and an updater function to change the settings.\n */\nexport const useSendSettings = ({ onSendSettingsUpdated }: Props = {}) => {\n  const daily = useDaily();\n  const [sendSettings, setSendSettings] = useAtom(sendSettingsState);\n\n  useDailyEvent(\n    'send-settings-updated',\n    useCallback(\n      (ev: DailyEventObject<'send-settings-updated'>) => {\n        setSendSettings(ev.sendSettings);\n        onSendSettingsUpdated?.(ev);\n      },\n      [onSendSettingsUpdated, setSendSettings]\n    )\n  );\n\n  const storeSendSettings = useCallback(\n    (sendSettings: DailySendSettings | null) => {\n      setSendSettings(sendSettings);\n    },\n    [setSendSettings]\n  );\n\n  useEffect(() => {\n    if (!daily || daily.isDestroyed()) return;\n    storeSendSettings(daily.getSendSettings());\n  }, [daily, storeSendSettings]);\n\n  /**\n   * Updates the local clients send settings.\n   * See https://docs.daily.co/reference/daily-js/instance-methods/update-send-settings for details.\n   */\n  const updateSendSettings = useCallback(\n    async (...args: Parameters<DailyCall['updateSendSettings']>) => {\n      const newSendSettings = await daily?.updateSendSettings(...args);\n      if (!newSendSettings) return;\n      storeSendSettings(newSendSettings);\n      return newSendSettings;\n    },\n    [daily, storeSendSettings]\n  );\n\n  const result = {\n    sendSettings,\n    updateSendSettings,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import {\n  DailyCall,\n  DailyEvent,\n  DailyEventObject,\n  DailyFactoryOptions,\n} from '@daily-co/daily-js';\n// Import Jotai Provider if you are using middleware that requires it\nimport { Provider } from 'jotai';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\n\nimport { DailyContext } from './DailyContext';\nimport { DailyDevices } from './DailyDevices';\nimport { DailyEventContext } from './DailyEventContext';\nimport { DailyLiveStreaming } from './DailyLiveStreaming';\nimport { DailyMeeting } from './DailyMeeting';\nimport { DailyNetwork } from './DailyNetwork';\nimport { DailyParticipants } from './DailyParticipants';\nimport { DailyRecordings } from './DailyRecordings';\nimport { DailyRoom } from './DailyRoom';\nimport { DailyTranscriptions } from './DailyTranscriptions';\nimport { useCallObject } from './hooks/useCallObject';\n\ntype BaseProps =\n  | DailyFactoryOptions\n  | {\n      callObject: DailyCall | null;\n    };\n\ntype Props = BaseProps & {\n  jotaiStore?: React.ComponentProps<typeof Provider>['store'];\n};\n\ntype EventsMap = Partial<Record<DailyEvent, Map<number, Function>>>;\n\nexport const DailyProvider: React.FC<React.PropsWithChildren<Props>> = ({\n  children,\n  jotaiStore,\n  ...props\n}) => {\n  const eventsMap = useRef<EventsMap>({});\n\n  /**\n   * Generic event handler to loop through registered event callbacks.\n   */\n  const handleEvent = useCallback((ev: DailyEventObject) => {\n    if (!('action' in ev)) return;\n    const event = ev.action as DailyEvent;\n    const allHandlers = Array.from(eventsMap.current?.[event] ?? []);\n    const priorityHandlers = allHandlers.filter(([key]) => key < 0);\n    const normalHandlers = allHandlers.filter(([key]) => key > 0);\n    const sortedHandlers = [...priorityHandlers, ...normalHandlers];\n    for (let [, cb] of sortedHandlers) {\n      cb(ev);\n    }\n  }, []);\n\n  /**\n   * In case events are set up via useDailyEvent before a DailyCall instance is available,\n   * we'll register the events whenever daily is set.\n   */\n  const initEventHandlers = useCallback(\n    (daily: DailyCall) => {\n      if (!daily) return;\n      (Object.keys(eventsMap.current) as DailyEvent[]).forEach((event) => {\n        daily.off(event as DailyEvent, handleEvent);\n        if (!daily.isDestroyed()) {\n          daily.on(event as DailyEvent, handleEvent);\n        }\n      });\n    },\n    [handleEvent]\n  );\n\n  const externalCallObject = 'callObject' in props ? props.callObject : null;\n\n  const memoizedOptions = useMemo(\n    () => ('callObject' in props ? {} : props),\n    [props]\n  );\n  const internalCallObject = useCallObject({\n    options: memoizedOptions,\n    shouldCreateInstance: useCallback(() => {\n      return !('callObject' in props);\n    }, [props]),\n  });\n\n  const callObject = externalCallObject ?? internalCallObject;\n\n  useEffect(() => {\n    if (!callObject) return;\n    initEventHandlers(callObject);\n  }, [callObject, initEventHandlers]);\n\n  /**\n   * Registers event callback.\n   */\n  const on = useCallback(\n    (ev: DailyEvent, cb: Function, key: number) => {\n      if (!eventsMap.current[ev]) {\n        eventsMap.current[ev] = new Map();\n        if (callObject) {\n          /**\n           * Make sure only 1 event listener is registered at any time for handleEvent.\n           * Otherwise, events sent from daily-js might be handled multiple times.\n           */\n          callObject.off(ev, handleEvent);\n          if (!callObject.isDestroyed()) {\n            callObject.on(ev, handleEvent);\n          }\n        }\n      }\n      if (!eventsMap.current[ev]?.has(key)) {\n        eventsMap.current[ev]?.set(key, cb);\n      }\n    },\n    [callObject, handleEvent]\n  );\n\n  /**\n   * Unregisters event callback.\n   */\n  const off = useCallback(\n    (ev: DailyEvent, key: number) => {\n      eventsMap.current[ev]?.delete(key);\n      if (eventsMap.current[ev]?.size === 0) {\n        callObject?.off(ev, handleEvent);\n        delete eventsMap.current[ev];\n      }\n    },\n    [callObject, handleEvent]\n  );\n\n  return (\n    <Provider store={jotaiStore}>\n      <DailyContext.Provider value={callObject}>\n        <DailyEventContext.Provider value={{ on, off }}>\n          <DailyRoom>\n            <DailyMeeting>\n              <DailyNetwork>\n                <DailyParticipants>\n                  <DailyRecordings>\n                    <DailyLiveStreaming>\n                      <DailyTranscriptions>\n                        <DailyDevices>{children}</DailyDevices>\n                      </DailyTranscriptions>\n                    </DailyLiveStreaming>\n                  </DailyRecordings>\n                </DailyParticipants>\n              </DailyNetwork>\n            </DailyMeeting>\n          </DailyRoom>\n        </DailyEventContext.Provider>\n      </DailyContext.Provider>\n    </Provider>\n  );\n};\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useCallback, useDebugValue, useEffect, useState } from 'react';\n\nimport { activeIdState } from '../DailyParticipants';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\nimport { useParticipant } from './useParticipant';\n\ninterface UseActiveParticipantArgs {\n  /**\n   * If set to true, useActiveParticipant will never return the local participant.\n   */\n  ignoreLocal?: boolean;\n  /**\n   * Optional event callback for [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event listener.\n   */\n  onActiveSpeakerChange?(ev: DailyEventObject<'active-speaker-change'>): void;\n}\n\n/**\n * Returns the most recent participant mentioned in an [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.\n * @deprecated Use [useActiveSpeakerId](https://docs.daily.co/reference/daily-react/use-active-speaker-id) instead.\n */\nexport const useActiveParticipant = ({\n  ignoreLocal = false,\n  onActiveSpeakerChange,\n}: UseActiveParticipantArgs = {}) => {\n  const daily = useDaily();\n  const recentActiveId = useAtomValue(activeIdState);\n  const [activeId, setActiveId] = useState('');\n  const activeParticipant = useParticipant(activeId);\n\n  useEffect(() => {\n    if (!daily) return;\n    const local = daily?.participants()?.local;\n    if (ignoreLocal && recentActiveId === local?.session_id) return;\n\n    // setting activeId as string to avoid passing null to useParticipant hook\n    setActiveId(recentActiveId ?? '');\n  }, [daily, ignoreLocal, recentActiveId]);\n\n  useDailyEvent(\n    'active-speaker-change',\n    useCallback(\n      (ev) => {\n        onActiveSpeakerChange?.(ev);\n      },\n      [onActiveSpeakerChange]\n    )\n  );\n\n  useDebugValue(activeParticipant);\n\n  return activeParticipant;\n};\n","import { DailyEventObjectAppMessage } from '@daily-co/daily-js';\nimport { useCallback } from 'react';\n\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ntype SendAppMessage<Data = any> = (data: Data, to?: string) => void;\n\ninterface UseAppMessageArgs<Data> {\n  /**\n   * Optional event callback for [app-message](https://docs.daily.co/reference/daily-js/events/participant-events#app-message) event listener.\n   * Receives this hook's sendAppMessage as an additional argument to avoid circular dependencies.\n   */\n  onAppMessage?(\n    ev: DailyEventObjectAppMessage<Data>,\n    sendAppMessage?: SendAppMessage<Data>\n  ): void;\n}\n\n/**\n * React hook to setup [app-message](https://docs.daily.co/reference/daily-js/events/participant-events#app-message) listeners and\n * to send messages via [sendAppMessage](https://docs.daily.co/reference/daily-js/instance-methods/send-app-message).\n */\nexport const useAppMessage = <Data = any>({\n  onAppMessage,\n}: UseAppMessageArgs<Data> = {}) => {\n  const daily = useDaily();\n\n  const sendAppMessage: SendAppMessage<Data> = useCallback(\n    (data, to = '*') => {\n      if (!daily) return;\n      daily.sendAppMessage(data, to);\n    },\n    [daily]\n  );\n\n  const handleAppMessage = useCallback(\n    (ev: DailyEventObjectAppMessage<Data>) => {\n      onAppMessage?.(ev, sendAppMessage);\n    },\n    [onAppMessage, sendAppMessage]\n  );\n\n  useDailyEvent('app-message', handleAppMessage);\n\n  return sendAppMessage;\n};\n","import { useEffect, useRef } from 'react';\n\nimport { inlineAudioWorklet } from '../lib/inlineAudioWorklet';\n/**\n * Returns the volume level of a given MediaStreamTrack.\n * @param mediaTrack The MediaStreamTrack to be analysed.\n * @param onVolumeChange The function to execute when the volume changes. Can be used to visualise audio output.\n * @deprecated Use useAudioLevelObserver() instead.\n */\nexport const useAudioLevel = (\n  mediaTrack: MediaStreamTrack | undefined,\n  onVolumeChange: (volume: number) => void\n) => {\n  const audioCtx = useRef<AudioContext>();\n\n  useEffect(\n    function setupStreamAndStartProcessing() {\n      // No mediaTrack. Stop immediately.\n      if (!mediaTrack) return;\n      const AudioCtx =\n        typeof AudioContext !== 'undefined'\n          ? AudioContext\n          : typeof window.webkitAudioContext !== 'undefined'\n          ? window.webkitAudioContext\n          : null;\n      // No AudioContext available in browser. Can't measure audio volume.\n      if (!AudioCtx) return;\n      if (!audioCtx.current) {\n        // No audio context initialized. Initializing now.\n        audioCtx.current = new AudioCtx();\n      }\n      const audioContext = audioCtx.current;\n      // Audio context could not be initialized. Stopping.\n      if (!audioContext) return;\n\n      // No MediaStream API available (e.g. WebRTC disabled)\n      if (!MediaStream) return;\n\n      const mediaStreamSource = audioContext.createMediaStreamSource(\n        new MediaStream([mediaTrack])\n      );\n      let node: AudioWorkletNode | null;\n      let gainNode: GainNode;\n\n      const startProcessing = async () => {\n        /**\n         * Try to add the module only once.\n         * In case it's not added to the audio context, yet, trying to initialize it will fail.\n         * There's only one real reason for `new AudioWorkletNode` to fail and that is\n         * when the corresponding module isn't added to the audio context, yet.\n         * This makes sure we only add the module once.\n         *\n         * We're inlining the worklet instead of loading it via a URL as not to complicate bundling\n         * this package.\n         */\n        try {\n          node = new AudioWorkletNode(audioContext, 'audiolevel');\n          gainNode = audioContext.createGain();\n        } catch {\n          try {\n            await audioContext.audioWorklet.addModule(inlineAudioWorklet);\n            node = new AudioWorkletNode(audioContext, 'audiolevel');\n            gainNode = audioContext.createGain();\n          } catch (e) {\n            console.error(e);\n          }\n        }\n\n        if (!(node && gainNode)) return;\n\n        node.port.onmessage = (event) => {\n          let volume = 0;\n          if (event.data.volume) volume = event.data.volume;\n          if (!node) return;\n          onVolumeChange(volume);\n        };\n\n        gainNode.gain.value = 0;\n\n        try {\n          mediaStreamSource\n            .connect(node)\n            .connect(gainNode)\n            .connect(audioContext.destination);\n        } catch (e) {\n          console.warn(e);\n        }\n      };\n\n      startProcessing();\n\n      return () => {\n        node?.disconnect();\n        node = null;\n        mediaStreamSource?.disconnect();\n      };\n    },\n    [onVolumeChange, mediaTrack]\n  );\n};\n","import { useCallback, useEffect } from 'react';\n\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\nimport { useLocalSessionId } from './useLocalSessionId';\n\ntype AudioLevelCallback = (volume: number) => void;\ntype ErrorCallback = (errorMsg: string) => void;\n\n/**\n * Observes the volume level for a given participant.\n * @param id The session_id of the participant to observe.\n * @param cb The function to execute when the volume changes. Can be used to visualise audio output.\n * @param errorCb Error callback. Called when local audio level observer is not available in browser.\n */\nexport const useAudioLevelObserver = (\n  id: string,\n  cb: AudioLevelCallback,\n  errorCb?: ErrorCallback\n) => {\n  const daily = useDaily();\n  const localSessionId = useLocalSessionId();\n  const isLocal = id === localSessionId;\n\n  useDailyEvent(\n    'local-audio-level',\n    useCallback(\n      (ev) => {\n        if (!isLocal) return;\n        cb(ev.audioLevel);\n      },\n      [cb, isLocal]\n    )\n  );\n\n  useDailyEvent(\n    'remote-participants-audio-level',\n    useCallback(\n      (ev) => {\n        if (isLocal) return;\n        cb(ev.participantsAudioLevel[id]);\n      },\n      [cb, id, isLocal]\n    )\n  );\n\n  useEffect(\n    function maybeStartLocalAudioObserver() {\n      if (!daily || daily.isDestroyed() || !isLocal) return;\n      if (daily.isLocalAudioLevelObserverRunning()) return;\n      try {\n        daily.startLocalAudioLevelObserver();\n      } catch {\n        errorCb?.('Local audio level observer not supported in this browser');\n      }\n    },\n    [daily, errorCb, isLocal]\n  );\n\n  useEffect(\n    function maybeStartRemoteAudioObserver() {\n      if (!daily || daily.isDestroyed() || isLocal) return;\n      if (daily.isRemoteParticipantsAudioLevelObserverRunning()) return;\n      daily.startRemoteParticipantsAudioLevelObserver();\n    },\n    [daily, isLocal]\n  );\n};\n","import { MediaTrackState, useMediaTrack } from './useMediaTrack';\n\n/**\n * Returns a participant's audio track and state.\n * @param participantId The participant's session_id.\n */\nexport const useAudioTrack = (participantId: string): MediaTrackState =>\n  useMediaTrack(participantId, 'audio');\n","import { useCallInstance } from './useCallInstance';\n\ntype Props = Parameters<typeof useCallInstance>[1];\n\n/**\n * Helper hook to maintain custom callFrame instances in React codebases.\n */\nexport const useCallFrame = (props: Props) =>\n  useCallInstance('callFrame', props);\n","import { useAtomValue } from 'jotai';\nimport { useCallback, useContext, useDebugValue } from 'react';\n\nimport {\n  cameraDevicesState,\n  generalCameraState,\n  generalMicrophoneState,\n  lastCameraErrorState,\n  microphoneDevicesState,\n  speakerDevicesState,\n} from '../DailyDevices';\nimport { DailyDevicesContext } from '../DailyDevicesContext';\nimport { useDaily } from './useDaily';\n\n/**\n * This hook allows access to information about the user's devices and their state.\n */\nexport const useDevices = () => {\n  const daily = useDaily();\n\n  const camState = useAtomValue(generalCameraState);\n  const micState = useAtomValue(generalMicrophoneState);\n  const camDevices = useAtomValue(cameraDevicesState);\n  const micDevices = useAtomValue(microphoneDevicesState);\n  const speakerDevices = useAtomValue(speakerDevicesState);\n  const cameraError = useAtomValue(lastCameraErrorState);\n\n  const { refreshDevices } = useContext(DailyDevicesContext);\n\n  /**\n   * Sets video input device to given deviceId.\n   */\n  const setCamera = useCallback(\n    async (deviceId: string) => {\n      await daily?.setInputDevicesAsync({\n        audioDeviceId: null,\n        videoDeviceId: deviceId,\n      });\n    },\n    [daily]\n  );\n\n  /**\n   * Sets audio input device to given deviceId.\n   */\n  const setMicrophone = useCallback(\n    async (deviceId: string) => {\n      await daily?.setInputDevicesAsync({\n        audioDeviceId: deviceId,\n        videoDeviceId: null,\n      });\n    },\n    [daily]\n  );\n\n  /**\n   * Sets audio output device to given deviceId.\n   */\n  const setSpeaker = useCallback(\n    async (deviceId: string) => {\n      await daily?.setOutputDeviceAsync({\n        outputDeviceId: deviceId,\n      });\n    },\n    [daily]\n  );\n\n  const errorStates: typeof camState[] = [\n    'blocked',\n    'in-use',\n    'not-found',\n    'constraints-invalid',\n    'constraints-none-specified',\n    'undefined-mediadevices',\n    'unknown',\n  ];\n\n  const result = {\n    /**\n     * Most recent error object emitted via [camera-error event](https://docs.daily.co/reference/daily-js/events/meeting-events#camera-error).\n     */\n    cameraError,\n    /**\n     * A list of the user's camera (videoinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.\n     */\n    cameras: camDevices,\n    /**\n     * The general state for camera access.\n     */\n    camState,\n    /**\n     * Holds the currently selected camera.\n     */\n    currentCam: camDevices.find((cam) => cam.selected),\n    /**\n     * Holds the currently selected microphone.\n     */\n    currentMic: micDevices.find((mic) => mic.selected),\n    /**\n     * Holds the currently selected speaker.\n     */\n    currentSpeaker: speakerDevices.find((speaker) => speaker.selected),\n    /**\n     * Indicates that there's an issue with camera devices.\n     */\n    hasCamError: errorStates.includes(camState),\n    /**\n     * Indicates that there's an issue with microphone devices.\n     */\n    hasMicError: errorStates.includes(micState),\n    /**\n     * A list of the user's microphone (audioinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.\n     */\n    microphones: micDevices,\n    /**\n     * The general state for microphone access.\n     */\n    micState,\n    /**\n     * Refreshes the list of devices using [enumerateDevices](https://docs.daily.co/reference/daily-js/instance-methods/enumerate-devices).\n     */\n    refreshDevices,\n    /**\n     * Allows to switch to the camera with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.\n     */\n    setCamera,\n    /**\n     * Allows to switch to the microphone with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.\n     */\n    setMicrophone,\n    /**\n     * Allows to switch to the speaker with the specified deviceId. Calls [setOutputDevice](https://docs.daily.co/reference/daily-js/instance-methods/set-output-device) internally.\n     */\n    setSpeaker,\n    /**\n     * A list of the user's speaker (audiooutput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.\n     */\n    speakers: speakerDevices,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailyEventObjectNonFatalError,\n} from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useCallback, useDebugValue } from 'react';\n\nimport { liveStreamingState } from '../DailyLiveStreaming';\nimport { Reconstruct } from '../types/Reconstruct';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ntype DailyEventObjectLiveStreamingWarning = Reconstruct<\n  DailyEventObjectNonFatalError,\n  'type',\n  'live-streaming-warning'\n>;\n\ninterface UseLiveStreamingArgs {\n  onLiveStreamingStarted?(ev: DailyEventObject<'live-streaming-started'>): void;\n  onLiveStreamingStopped?(ev: DailyEventObject<'live-streaming-stopped'>): void;\n  onLiveStreamingUpdated?(ev: DailyEventObject<'live-streaming-updated'>): void;\n  onLiveStreamingError?(ev: DailyEventObject<'live-streaming-error'>): void;\n  onLiveStreamingWarning?(ev: DailyEventObjectLiveStreamingWarning): void;\n}\n\n/**\n * This hook allows to setup [live streaming events](https://docs.daily.co/reference/daily-js/events/live-streaming-events),\n * as well as starting, stopping and updating live streams.\n *\n * Returns the current live streaming state, incl. the current layout and potential errorMsg.\n */\nexport const useLiveStreaming = ({\n  onLiveStreamingError,\n  onLiveStreamingStarted,\n  onLiveStreamingStopped,\n  onLiveStreamingUpdated,\n  onLiveStreamingWarning,\n}: UseLiveStreamingArgs = {}) => {\n  const daily = useDaily();\n  const state = useAtomValue(liveStreamingState);\n\n  useDailyEvent(\n    'live-streaming-started',\n    useCallback(\n      (ev) => {\n        onLiveStreamingStarted?.(ev);\n      },\n      [onLiveStreamingStarted]\n    )\n  );\n  useDailyEvent(\n    'live-streaming-stopped',\n    useCallback(\n      (ev) => {\n        onLiveStreamingStopped?.(ev);\n      },\n      [onLiveStreamingStopped]\n    )\n  );\n  useDailyEvent(\n    'live-streaming-updated',\n    useCallback(\n      (ev) => {\n        onLiveStreamingUpdated?.(ev);\n      },\n      [onLiveStreamingUpdated]\n    )\n  );\n  useDailyEvent(\n    'live-streaming-error',\n    useCallback(\n      (ev) => {\n        onLiveStreamingError?.(ev);\n      },\n      [onLiveStreamingError]\n    )\n  );\n  useDailyEvent(\n    'nonfatal-error',\n    useCallback(\n      (ev) => {\n        if (ev.type !== 'live-streaming-warning') return;\n        onLiveStreamingWarning?.(ev as DailyEventObjectLiveStreamingWarning);\n      },\n      [onLiveStreamingWarning]\n    )\n  );\n\n  const startLiveStreaming = useCallback(\n    (...args: Parameters<DailyCall['startLiveStreaming']>) => {\n      if (!daily) return;\n      daily.startLiveStreaming(...args);\n    },\n    [daily]\n  );\n\n  const stopLiveStreaming = useCallback(\n    (...args: Parameters<DailyCall['stopLiveStreaming']>) => {\n      if (!daily) return;\n      daily.stopLiveStreaming(...args);\n    },\n    [daily]\n  );\n\n  const updateLiveStreaming = useCallback(\n    (...args: Parameters<DailyCall['updateLiveStreaming']>) => {\n      if (!daily) return;\n      daily.updateLiveStreaming(...args);\n    },\n    [daily]\n  );\n\n  const result = {\n    ...state,\n    startLiveStreaming,\n    stopLiveStreaming,\n    updateLiveStreaming,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { useAtomValue } from 'jotai';\nimport { useDebugValue } from 'react';\n\nimport { localIdState } from '../DailyParticipants';\nimport { useParticipant } from './useParticipant';\n\n/**\n * Returns the [participants() object](https://docs.daily.co/reference/daily-js/instance-methods/participants) for the local user.\n * @deprecated Use [useLocalSessionId](https://docs.daily.co/reference/daily-react/use-local-session-id) instead.\n */\nexport const useLocalParticipant = (): ReturnType<typeof useParticipant> => {\n  const localId = useAtomValue(localIdState);\n  const localParticipant = useParticipant(localId);\n  useDebugValue(localParticipant);\n  return localParticipant;\n};\n","import { DailyEventObjectNonFatalError } from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useCallback, useDebugValue } from 'react';\n\nimport { meetingSessionDataState } from '../DailyMeeting';\nimport { Reconstruct } from '../types/Reconstruct';\nimport { useDailyEvent } from './useDailyEvent';\n\ntype DailyEventObjectMeetingSessionDataError = Reconstruct<\n  DailyEventObjectNonFatalError,\n  'type',\n  'meeting-session-data-error'\n>;\n\ninterface Props {\n  onError?(ev: DailyEventObjectMeetingSessionDataError): void;\n}\n\n/**\n * Returns a meeting's current session data and topology.\n */\nexport const useMeetingSessionState = <T = any>({ onError }: Props = {}) => {\n  const meetingSessionState = useAtomValue(meetingSessionDataState);\n\n  useDailyEvent(\n    'nonfatal-error',\n    useCallback(\n      (ev) => {\n        if (ev.type !== 'meeting-session-data-error') return;\n        onError?.(ev as DailyEventObjectMeetingSessionDataError);\n      },\n      [onError]\n    )\n  );\n\n  const result = {\n    data: meetingSessionState?.data as T,\n    topology: meetingSessionState?.topology,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useCallback, useDebugValue } from 'react';\n\nimport {\n  networkQualityState,\n  networkThresholdState,\n  topologyState,\n} from '../DailyNetwork';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ninterface UseNetworkArgs {\n  onNetworkConnection?(ev: DailyEventObject<'network-connection'>): void;\n  onNetworkQualityChange?(ev: DailyEventObject<'network-quality-change'>): void;\n}\n\n/**\n * Returns current information about network quality and topology.\n * Allows to setup event listeners for daily's [network events](https://docs.daily.co/reference/daily-js/events/network-events).\n */\nexport const useNetwork = ({\n  onNetworkConnection,\n  onNetworkQualityChange,\n}: UseNetworkArgs = {}) => {\n  const daily = useDaily();\n\n  const topology = useAtomValue(topologyState);\n  const quality = useAtomValue(networkQualityState);\n  const threshold = useAtomValue(networkThresholdState);\n\n  useDailyEvent(\n    'network-connection',\n    useCallback(\n      (ev) => {\n        onNetworkConnection?.(ev);\n      },\n      [onNetworkConnection]\n    )\n  );\n  useDailyEvent(\n    'network-quality-change',\n    useCallback(\n      (ev) => {\n        onNetworkQualityChange?.(ev);\n      },\n      [onNetworkQualityChange]\n    )\n  );\n\n  const getStats = useCallback(async () => {\n    const newStats = await daily?.getNetworkStats();\n    return newStats?.stats;\n  }, [daily]);\n\n  const result = {\n    getStats,\n    quality,\n    threshold,\n    topology,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { useDebugValue } from 'react';\n\nimport { useLocalSessionId } from './useLocalSessionId';\nimport { useParticipantProperty } from './useParticipantProperty';\n\n/**\n * Returns parsed permissions for a given participant.\n * In case no `sessionId` is passed, the hook returns permissions for the local participant.\n * @param sessionId The participant's session_id (optional)\n */\nexport const usePermissions = (sessionId?: string) => {\n  const localSessionId = useLocalSessionId();\n  const permissions = useParticipantProperty(\n    sessionId ?? localSessionId,\n    'permissions'\n  );\n\n  const canSendAudio =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('audio'));\n  const canSendVideo =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('video'));\n  const canSendCustomAudio =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('customAudio'));\n  const canSendCustomVideo =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('customVideo'));\n  const canSendScreenAudio =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('screenAudio'));\n  const canSendScreenVideo =\n    typeof permissions?.canSend === 'boolean'\n      ? permissions?.canSend\n      : Boolean(permissions?.canSend?.has('screenVideo'));\n  const canAdminParticipants =\n    typeof permissions?.canAdmin === 'boolean'\n      ? permissions?.canAdmin\n      : Boolean(permissions?.canAdmin?.has('participants'));\n  const canAdminStreaming =\n    typeof permissions?.canAdmin === 'boolean'\n      ? permissions?.canAdmin\n      : Boolean(permissions?.canAdmin?.has('streaming'));\n  const canAdminTranscription =\n    typeof permissions?.canAdmin === 'boolean'\n      ? permissions?.canAdmin\n      : Boolean(permissions?.canAdmin?.has('transcription'));\n\n  const result = {\n    canAdminParticipants,\n    canAdminStreaming,\n    canAdminTranscription,\n    canSendAudio,\n    canSendCustomAudio,\n    canSendCustomVideo,\n    canSendScreenAudio,\n    canSendScreenVideo,\n    canSendVideo,\n    hasPresence: permissions?.hasPresence,\n    permissions,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { DailyCall, DailyEventObject } from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useCallback, useDebugValue } from 'react';\n\nimport { recordingState } from '../DailyRecordings';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ninterface UseRecordingArgs {\n  onRecordingData?(ev: DailyEventObject<'recording-data'>): void;\n  onRecordingError?(ev: DailyEventObject<'recording-error'>): void;\n  onRecordingStarted?(ev: DailyEventObject<'recording-started'>): void;\n  onRecordingStopped?(ev: DailyEventObject<'recording-stopped'>): void;\n}\n\nexport const useRecording = ({\n  onRecordingData,\n  onRecordingError,\n  onRecordingStarted,\n  onRecordingStopped,\n}: UseRecordingArgs = {}) => {\n  const daily = useDaily();\n  const state = useAtomValue(recordingState);\n\n  useDailyEvent(\n    'recording-started',\n    useCallback(\n      (ev) => {\n        onRecordingStarted?.(ev);\n      },\n      [onRecordingStarted]\n    )\n  );\n  useDailyEvent(\n    'recording-stopped',\n    useCallback(\n      (ev) => {\n        onRecordingStopped?.(ev);\n      },\n      [onRecordingStopped]\n    )\n  );\n  useDailyEvent(\n    'recording-error',\n    useCallback(\n      (ev) => {\n        onRecordingError?.(ev);\n      },\n      [onRecordingError]\n    )\n  );\n  useDailyEvent(\n    'recording-data',\n    useCallback(\n      (ev) => {\n        onRecordingData?.(ev);\n      },\n      [onRecordingData]\n    )\n  );\n\n  /**\n   * Starts the recording with the given optional options.\n   */\n  const startRecording = useCallback(\n    (...args: Parameters<DailyCall['startRecording']>) => {\n      if (!daily) return;\n      daily.startRecording(...args);\n    },\n    [daily]\n  );\n\n  /**\n   * Stops a recording.\n   */\n  const stopRecording = useCallback(\n    (...args: Parameters<DailyCall['stopRecording']>) => {\n      if (!daily) return;\n      daily.stopRecording(...args);\n    },\n    [daily]\n  );\n\n  /**\n   * Updates a running recording's layout configuration.\n   */\n  const updateRecording = useCallback(\n    (...args: Parameters<DailyCall['updateRecording']>) => {\n      if (!daily) return;\n      daily.updateRecording(...args);\n    },\n    [daily]\n  );\n\n  const result = {\n    ...state,\n    startRecording,\n    stopRecording,\n    updateRecording,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { useAtomValue } from 'jotai';\nimport { useDebugValue, useEffect, useState } from 'react';\n\nimport { localJoinDateState } from '../DailyParticipants';\nimport { useRoom } from './useRoom';\n\ninterface Countdown {\n  hours: number;\n  minutes: number;\n  seconds: number;\n}\n\ninterface Props {\n  onCountdown?(countdown: Countdown): void;\n}\n\nexport const useRoomExp = ({ onCountdown }: Props = {}) => {\n  const localJoinDate = useAtomValue(localJoinDateState);\n  const room = useRoom();\n\n  const [ejectDate, setEjectDate] = useState<Date | null>(null);\n\n  useEffect(() => {\n    const expCandidates: number[] = [];\n\n    const ejectAfterElapsed =\n      room?.tokenConfig?.eject_after_elapsed ??\n      room?.config?.eject_after_elapsed ??\n      0;\n\n    if (ejectAfterElapsed && localJoinDate) {\n      expCandidates.push(localJoinDate.getTime() + 1000 * ejectAfterElapsed);\n    }\n    if (room?.tokenConfig?.exp && room?.tokenConfig?.eject_at_token_exp) {\n      expCandidates.push(room.tokenConfig.exp * 1000);\n    }\n    if (room?.config?.exp && room?.config?.eject_at_room_exp) {\n      expCandidates.push(room.config.exp * 1000);\n    }\n\n    const newEjectDate =\n      expCandidates.length > 0\n        ? new Date(Math.min(...expCandidates))\n        : new Date(0);\n\n    if (newEjectDate.getTime() === 0) return;\n\n    setEjectDate((oldEjectDate) =>\n      oldEjectDate?.getTime() !== newEjectDate.getTime()\n        ? newEjectDate\n        : oldEjectDate\n    );\n  }, [\n    localJoinDate,\n    room?.config?.eject_after_elapsed,\n    room?.config?.eject_at_room_exp,\n    room?.config?.exp,\n    room?.tokenConfig?.eject_after_elapsed,\n    room?.tokenConfig?.eject_at_token_exp,\n    room?.tokenConfig?.exp,\n  ]);\n\n  useEffect(() => {\n    if (!ejectDate || ejectDate.getTime() === 0) return;\n\n    const interval = setInterval(() => {\n      const eject = (ejectDate?.getTime() ?? 0) / 1000;\n      const now = Date.now() / 1000;\n      const diff = eject - now;\n      if (diff < 0) return;\n      const hours = Math.max(0, Math.floor(diff / 3600));\n      const minutes = Math.max(0, Math.floor((diff % 3600) / 60));\n      const seconds = Math.max(0, Math.floor(diff % 60));\n      onCountdown?.({\n        hours,\n        minutes,\n        seconds,\n      });\n    }, 1000);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [ejectDate, onCountdown]);\n\n  const result = {\n    ejectDate,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { MediaTrackState, useMediaTrack } from './useMediaTrack';\n\n/**\n * Returns a participant's screenAudio track and state.\n * @param participantId The participant's session_id.\n */\nexport const useScreenAudioTrack = (participantId: string): MediaTrackState =>\n  useMediaTrack(participantId, 'screenAudio');\n","import { MediaTrackState, useMediaTrack } from './useMediaTrack';\n\n/**\n * Returns a participant's screenVideo track and state.\n * @param participantId The participant's session_id.\n */\nexport const useScreenVideoTrack = (participantId: string): MediaTrackState =>\n  useMediaTrack(participantId, 'screenVideo');\n","import {\n  DailyCall,\n  DailyEventObject,\n  DailyEventObjectAppMessage,\n} from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useCallback, useDebugValue } from 'react';\n\nimport { Transcription, transcriptionState } from '../DailyTranscriptions';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ninterface UseTranscriptionArgs {\n  onTranscriptionStarted?(ev: DailyEventObject<'transcription-started'>): void;\n  onTranscriptionStopped?(ev: DailyEventObject<'transcription-stopped'>): void;\n  onTranscriptionError?(ev: DailyEventObject<'transcription-error'>): void;\n  /**\n   * @deprecated Please use onTranscriptionMessage instead.\n   */\n  onTranscriptionAppData?(ev: DailyEventObjectAppMessage<Transcription>): void;\n  onTranscriptionMessage?(ev: DailyEventObject<'transcription-message'>): void;\n}\n\nexport const useTranscription = ({\n  onTranscriptionAppData,\n  onTranscriptionError,\n  onTranscriptionMessage,\n  onTranscriptionStarted,\n  onTranscriptionStopped,\n}: UseTranscriptionArgs = {}) => {\n  const daily = useDaily();\n\n  const state = useAtomValue(transcriptionState);\n\n  useDailyEvent(\n    'transcription-started',\n    useCallback(\n      (ev) => {\n        onTranscriptionStarted?.(ev);\n      },\n      [onTranscriptionStarted]\n    )\n  );\n  useDailyEvent(\n    'transcription-stopped',\n    useCallback(\n      (ev) => {\n        onTranscriptionStopped?.(ev);\n      },\n      [onTranscriptionStopped]\n    )\n  );\n  useDailyEvent(\n    'transcription-error',\n    useCallback(\n      (ev) => {\n        onTranscriptionError?.(ev);\n      },\n      [onTranscriptionError]\n    )\n  );\n  useDailyEvent(\n    'transcription-message',\n    useCallback(\n      (ev) => {\n        onTranscriptionMessage?.(ev);\n      },\n      [onTranscriptionMessage]\n    )\n  );\n  useDailyEvent(\n    'app-message',\n    useCallback(\n      (ev: DailyEventObjectAppMessage<Transcription>) => {\n        if (ev?.fromId === 'transcription') {\n          onTranscriptionAppData?.(ev);\n        }\n      },\n      [onTranscriptionAppData]\n    )\n  );\n\n  /**\n   * Starts the transcription with the given optional options.\n   */\n  const startTranscription = useCallback(\n    (...args: Parameters<DailyCall['startTranscription']>) => {\n      if (!daily) return;\n      daily.startTranscription(...args);\n    },\n    [daily]\n  );\n\n  /**\n   * Stops a transcription.\n   */\n  const stopTranscription = useCallback(\n    (...args: Parameters<DailyCall['stopTranscription']>) => {\n      if (!daily) return;\n      daily.stopTranscription(...args);\n    },\n    [daily]\n  );\n\n  const result = {\n    ...state,\n    startTranscription,\n    stopTranscription,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n","import { MediaTrackState, useMediaTrack } from './useMediaTrack';\n\n/**\n * Returns a participant's video track and state.\n * @param participantId The participant's session_id.\n */\nexport const useVideoTrack = (participantId: string): MediaTrackState =>\n  useMediaTrack(participantId, 'video');\n","import { DailyEventObject } from '@daily-co/daily-js';\nimport { useAtomValue } from 'jotai';\nimport { useCallback, useDebugValue } from 'react';\n\nimport { allWaitingParticipantsSelector } from '../DailyParticipants';\nimport { useDaily } from './useDaily';\nimport { useDailyEvent } from './useDailyEvent';\n\ninterface UseWaitingParticipantsArgs {\n  onWaitingParticipantAdded?(\n    ev: DailyEventObject<'waiting-participant-added'>\n  ): void;\n  onWaitingParticipantUpdated?(\n    ev: DailyEventObject<'waiting-participant-updated'>\n  ): void;\n  onWaitingParticipantRemoved?(\n    ev: DailyEventObject<'waiting-participant-removed'>\n  ): void;\n}\n\n/**\n * Hook to access and manage waiting participants.\n */\nexport const useWaitingParticipants = ({\n  onWaitingParticipantAdded,\n  onWaitingParticipantRemoved,\n  onWaitingParticipantUpdated,\n}: UseWaitingParticipantsArgs = {}) => {\n  const daily = useDaily();\n\n  const waitingParticipants = useAtomValue(\n    allWaitingParticipantsSelector(undefined)\n  );\n\n  useDailyEvent(\n    'waiting-participant-added',\n    useCallback(\n      (ev) => {\n        onWaitingParticipantAdded?.(ev);\n      },\n      [onWaitingParticipantAdded]\n    )\n  );\n  useDailyEvent(\n    'waiting-participant-removed',\n    useCallback(\n      (ev) => {\n        onWaitingParticipantRemoved?.(ev);\n      },\n      [onWaitingParticipantRemoved]\n    )\n  );\n  useDailyEvent(\n    'waiting-participant-updated',\n    useCallback(\n      (ev) => {\n        onWaitingParticipantUpdated?.(ev);\n      },\n      [onWaitingParticipantUpdated]\n    )\n  );\n\n  const updateWaitingParticipantAccess = useCallback(\n    (id: '*' | string, grantRequestedAccess: boolean) => {\n      if (id === '*') {\n        daily?.updateWaitingParticipants({\n          '*': {\n            grantRequestedAccess,\n          },\n        });\n        return;\n      }\n      daily?.updateWaitingParticipant(id, {\n        grantRequestedAccess,\n      });\n    },\n    [daily]\n  );\n\n  const grantAccess = useCallback(\n    (id: '*' | string) => {\n      updateWaitingParticipantAccess(id, true);\n    },\n    [updateWaitingParticipantAccess]\n  );\n\n  const denyAccess = useCallback(\n    (id: '*' | string) => {\n      updateWaitingParticipantAccess(id, false);\n    },\n    [updateWaitingParticipantAccess]\n  );\n\n  const result = {\n    waitingParticipants,\n    grantAccess,\n    denyAccess,\n  };\n\n  useDebugValue(result);\n\n  return result;\n};\n"],"names":["DailyContext","createContext","useDaily","daily","useContext","useDebugValue","DailyEventContext","on","off","priorityCounter","getPriorityUnique","uniqueCounter","getUnique","useDailyEvent","ev","callback","INTERNAL_priority","_useContext","_useState","useState","isBlocked","setIsBlocked","reassignCount","useRef","eventId","useMemo","useEffect","current","console","error","timeout","setTimeout","clearTimeout","event","customDeepEqual","a","b","Array","isArray","length","i","MediaStream","id","active","getTracks","every","track","idx","MediaStreamTrack","kind","readyState","Date","getTime","RegExp","source","flags","Set","size","arrA","from","sort","arrB","val","Map","_step","_iterator","_createForOfIteratorHelperLoose","entries","done","_step$value","value","key","has","get","keysA","Object","keys","keysB","prototype","hasOwnProperty","call","arraysDeepEqual","valueA","valueB","jotaiDebugLabel","label","equalAtomFamily","options","atomCache","priorValues","param","baseAtom","atom","derivedValue","prior","equals","set","getPropertyParam","property","getParticipantPropertyAtom","participantPropertyState","participantPropertyPathsState","atomFamily","participantPropertyPathsAtom","debugLabel","participantPropertyAtom","participantPropertiesState","_param$split","split","map","path","useParticipantProperty","participantId","propertyPaths","properties","useAtomValue","join","getPropertiesParam","reduce","o","_ref","useThrottledDailyEvent","throttleTimeout","r","e","throttledEvents","useCallback","emitEvents","throttle","trailing","addEvent","push","forEach","getParticipantPaths","p","getPaths","currentPath","visited","add","paths","newPath","apply","concat","resolveParticipantPaths","participant","String","filter","resolvePath","activeIdState","localIdState","localJoinDateState","participantIdsState","participantState","participantAtom","waitingParticipantsState","waitingParticipantState","waitingParticipantAtom","awaitingAccess","level","name","allWaitingParticipantsSelector","DailyParticipants","children","initialized","setInitialized","initParticipants","useAtomCallback","_get","participants","local","session_id","participantsArray","values","ids","interval","setInterval","clearInterval","handleInitEvent","handleCleanup","remove","evts","action","activeSpeaker","peerId","prev","_extends","last_active","prevIds","includes","oldPaths","some","oldPathSet","resolvedValues","wps","wp","React","useLocalSessionId","localId","noopFilter","useActiveSpeakerId","_temp","_ref$filter","_ref$ignoreLocal","ignoreLocal","localSessionId","recentActiveId","isIgnoredLocalId","isFilteredOut","activeId","setActiveId","isTrackOff","trackState","getParticipantIdsFilterSortParam","participantIdsFilteredAndSortedState","screenAudioState","screenVideoState","idA","idB","aSort","bSort","undefined","useParticipantIds","onActiveSpeakerChange","onParticipantJoined","onParticipantLeft","onParticipantUpdated","preFilteredSortedIds","shouldUseCustomIds","getCustomFilteredIds","Boolean","customIds","setCustomIds","maybeUpdateCustomIds","newIds","result","screenSharesState","screenAudio","screenVideo","screenId","useScreenShare","onError","onLocalScreenShareStarted","onLocalScreenShareStopped","startScreenShare","args","_len","_key","arguments","stopScreenShare","_len2","_key2","type","screens","isSharingScreen","s","useMediaTrack","isOff","state","persistentTrack","subscribed","useMergedRef","refs","element","ref","DailyAudioTrack","memo","forwardRef","onPlayFailed","sessionId","_ref$type","props","_objectWithoutPropertiesLoose","_excluded","audioEl","audio","audioRef","subscribedState","audioTag","handleCanPlay","play","target","message","handlePlay","playTimeout","addEventListener","srcObject","removeEventListener","warn","autoPlay","displayName","DailyAudio","autoSubscribeActiveSpeaker","_ref$autoSubscribeAct","_ref$maxSpeakers","maxSpeakers","_ref$playLocalScreenA","playLocalScreenAudio","fill","speakers","setSpeakers","activeSpeakerId","containerRef","useImperativeHandle","getActiveSpeakerAudio","_containerRef$current","_containerRef$current2","querySelector","getAllAudio","_containerRef$current3","_containerRef$current4","querySelectorAll","getAudioBySessionId","_containerRef$current5","_containerRef$current6","getRmpAudio","_containerRef$current7","_containerRef$current8","getScreenAudio","_containerRef$current9","_containerRef$current10","getRmpAudioBySessionId","_containerRef$current11","_containerRef$current12","getScreenAudioBySessionId","_containerRef$current13","_containerRef$current14","assignSpeaker","_ref2","_asyncToGenerator","_set","subscribedParticipants","_daily$participants","tracks","isSubscribed","isDestroyed","subscribeToTracksAutomatically","updateParticipant","setSubscribedTracks","prevSpeakers","freeSlotCheck","findIndex","mutedIdx","speakerObjects","lastActiveA","lastActiveB","_get2","replaceIdx","indexOf","_speakerObjects$","_x","_x2","_x3","removeSpeaker","newSpeakers","rmpAudioIds","_p$tracks","rmpAudio","screen","DailyVideo","automirror","_ref$fit","fit","mirror","onResize","_ref$playableStyle","playableStyle","_ref$style","style","isLocal","isScreen","isLocalCam","videoEl","videoRef","videoState","videoTrack","isPlayable","isMirrored","videoTrackSettings","getSettings","facingMode","video","playVideo","promise","then","controls","paused","handleEnterPIP","transform","handleLeavePIP","handleVisibilityChange","document","visibilityState","load","frame","handleResize","cancelAnimationFrame","requestAnimationFrame","hidden","videoWidth","videoHeight","aspectRatio","height","width","muted","playsInline","objectFit","DailyDevicesContext","refreshDevices","Promise","resolve","generalCameraState","generalMicrophoneState","cameraDevicesState","microphoneDevicesState","speakerDevicesState","lastCameraErrorState","DailyDevices","_navigator","navigator","_navigator$mediaDevic","mediaDevices","getUserMedia","_navigator2","_navigator2$mediaDevi","enumerateDevices","devices","cams","d","deviceId","mics","_yield$daily$getInput","getInputDevices","camera","mic","speaker","mapDevice","device","prevDevices","_prevDevices$find$sta","_prevDevices$find","selected","find","sortDeviceByLabel","prevCams","prevMics","updateDeviceStates","_ref3","currentCamState","currentMicState","camPermissionState","micPermissionState","permissions","query","_unused","awaitingCamAccess","initialCamOff","_tracks$video$off","byUser","awaitingMicAccess","initialMicOff","_tracks$audio$off","_tracks$audio","_tracks$audio$blocked","blocked","byDeviceInUse","m","_tracks$audio2","_tracks$audio2$blocke","byDeviceMissing","_tracks$audio3","_tracks$audio3$blocke","byPermissions","_tracks$video","_tracks$video$blocked","_tracks$video2","_tracks$video2$blocke","_tracks$video3","_tracks$video3$blocke","_x4","_ev$error","_ev$error2","missingMedia","_ev$error3","_ev$error4","blockedMedia","_ev$error5","_ev$error6","reason","_ev$error7","Provider","liveStreamingState","errorMsg","isLiveStreaming","layout","DailyLiveStreaming","prevState","meetingStateState","meetingErrorState","nonFatalErrorState","meetingSessionDataState","data","topology","DailyMeeting","updateMeetingState","meetingState","initMeetingSessionState","meetingSessionState","topologyState","networkQualityState","networkThresholdState","DailyNetwork","initTopology","getNetworkTopology","prevQuality","quality","prevThreshold","threshold","recordingState","isLocalParticipantRecorded","isRecording","DailyRecordings","recordingParticipantIds","maybeUpdateRecordingState","hasRecordingParticipants","isLocalParticipantRecording","oldState","newState","_ev$layout","preset","recordingId","recordingStartedDate","startedBy","useMeetingState","roomState","DailyRoom","updateRoom","room","transcriptionState","isTranscribing","model","language","transcriptions","DailyTranscriptions","transcriptionStartDate","endpointing","extra","includeRawResponse","instanceId","profanity_filter","punctuate","redact","tier","updatedBy","fromId","defaultOptions","defaultShouldCreateInstance","defaultProps","shouldCreateInstance","useCallInstance","parentElRef","_ref$options","_ref$shouldCreateInst","callInstance","setCallInstance","lastUsedOptions","handleDestroyedInstance","co","Daily","getCallInstance","once","_destroyCallInstance","destroyCallInstance","createFrame","createCallObject","destroy","useCallObject","useParticipant","filteredEvts","inlineAudioWorklet","encodeURIComponent","CPULoadState","useDailyError","meetingError","nonFatalError","inputSettingsState","participantCountsState","present","participantReceiveSettingsState","participantReceiveSettingsAtom","newValue","useRoom","sendSettingsState","jotaiStore","eventsMap","handleEvent","allHandlers","_eventsMap$current$ev","_eventsMap$current","priorityHandlers","normalHandlers","cb","initEventHandlers","externalCallObject","callObject","memoizedOptions","internalCallObject","_eventsMap$current$ev3","_eventsMap$current$ev2","_eventsMap$current$ev4","_eventsMap$current$ev5","store","activeParticipant","onAppMessage","sendAppMessage","to","handleAppMessage","mediaTrack","onVolumeChange","audioCtx","AudioCtx","AudioContext","window","webkitAudioContext","audioContext","node","gainNode","mediaStreamSource","createMediaStreamSource","AudioWorkletNode","createGain","audioWorklet","addModule","port","onmessage","volume","gain","connect","destination","startProcessing","_node","disconnect","errorCb","audioLevel","participantsAudioLevel","isLocalAudioLevelObserverRunning","startLocalAudioLevelObserver","isRemoteParticipantsAudioLevelObserverRunning","startRemoteParticipantsAudioLevelObserver","onCPULoadChange","cpu","updateCPULoadState","deepEqual","mounted","getCpuLoadStats","stats","cpuLoadState","cpuLoadStateReason","camState","micState","camDevices","micDevices","speakerDevices","cameraError","setCamera","setInputDevicesAsync","audioDeviceId","videoDeviceId","setMicrophone","setSpeaker","setOutputDeviceAsync","outputDeviceId","errorStates","cameras","currentCam","cam","currentMic","currentSpeaker","hasCamError","hasMicError","microphones","onInputSettingsUpdated","inputSettings","updateInputSettingsState","getInputSettings","updateInputSettings","onLiveStreamingError","onLiveStreamingStarted","onLiveStreamingStopped","onLiveStreamingUpdated","onLiveStreamingWarning","startLiveStreaming","stopLiveStreaming","updateLiveStreaming","localParticipant","onNetworkConnection","onNetworkQualityChange","getStats","newStats","getNetworkStats","onParticipantCountsUpdated","participantCounts","updateCounts","counts","canSendAudio","canSend","_permissions$canSend","canSendVideo","_permissions$canSend2","canSendCustomAudio","_permissions$canSend3","canSendCustomVideo","_permissions$canSend4","canSendScreenAudio","_permissions$canSend5","canSendScreenVideo","_permissions$canSend6","canAdminParticipants","canAdmin","_permissions$canAdmin","canAdminStreaming","_permissions$canAdmin2","canAdminTranscription","_permissions$canAdmin3","hasPresence","_ref$id","onReceiveSettingsUpdated","baseSettings","useAtom","receiveSettings","updateReceiveSettingsState","_i","_Object$entries","_Object$entries$_i","settings","getReceiveSettings","updateReceiveSettings","onRecordingData","onRecordingError","onRecordingStarted","onRecordingStopped","startRecording","stopRecording","updateRecording","onCountdown","localJoinDate","ejectDate","setEjectDate","expCandidates","ejectAfterElapsed","_room$tokenConfig$eje","_room$tokenConfig","tokenConfig","eject_after_elapsed","_room$config","config","_room$tokenConfig2","exp","_room$tokenConfig3","eject_at_token_exp","_room$config2","_room$config3","eject_at_room_exp","newEjectDate","Math","min","oldEjectDate","_room$config4","_room$config5","_room$config6","_room$tokenConfig4","_room$tokenConfig5","_room$tokenConfig6","diff","_ejectDate$getTime","now","hours","max","floor","minutes","seconds","onSendSettingsUpdated","_useAtom","sendSettings","setSendSettings","storeSendSettings","getSendSettings","updateSendSettings","newSendSettings","onTranscriptionAppData","onTranscriptionError","onTranscriptionMessage","onTranscriptionStarted","onTranscriptionStopped","startTranscription","stopTranscription","onWaitingParticipantAdded","onWaitingParticipantRemoved","onWaitingParticipantUpdated","waitingParticipants","updateWaitingParticipantAccess","grantRequestedAccess","updateWaitingParticipant","updateWaitingParticipants","*","grantAccess","denyAccess"],"mappings":"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"}