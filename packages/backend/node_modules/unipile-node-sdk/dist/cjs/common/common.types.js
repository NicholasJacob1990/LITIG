"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkedinRequestUrlValidator = exports.LinkedinRequestUrlSchema = exports.UniqueIdValidator = exports.makeUniqueIdSchema = exports.UniqueIdSchema = exports.NumberEnum = exports.StringEnum = void 0;
const typebox_1 = require("@sinclair/typebox");
const compiler_1 = require("@sinclair/typebox/compiler");
const i18n_fake_js_1 = require("./i18n.fake.js");
// /**
//  * @note The StringEnumType is not is not safe to express a union of strings. Iâ€™ve encountered a lot of validation problems with it.
//  * It is possible that the TypeRegistry.Set() is not used properly and overrides the StringEnumType definition everytime it is called.
//  */
// export function StringEnumType<T extends string[]>(
//   kind: string,
//   members: [...T],
//   options?: UnsafeOptions
// ) {
//   TypeRegistry.Set(kind, (schema, value) => members.includes(value as any));
//   return Type.Unsafe<T[number]>({
//     [Kind]: kind,
//     type: "string",
//     enum: members,
//     ...options,
//   });
// }
// /**
//  * This type is an alternative to an union of litterals which is not displayed properly by readme.io
//  * Idealy we want to use the StringEnumType but the it is not reliable at the moment.
//  */
// export function StringPatternType(
//   litterals: Array<string>,
//   options?: StringOptions
// ) {
//   const pattern = `^(${litterals.join("|")})$`;
//   const description = `Accepted values: ${litterals.join(" | ")}`;
//   return Type.String({ pattern, description, ...options });
// }
/**
 * @note Working solution for string unions where TypeRegistry.Set should be top level
 * Brings much better string union presentation in Readme
 * https://github.com/xddq/schema2typebox/issues/16
 */
typebox_1.TypeRegistry.Set('StringEnum', (schema, value) => schema.enum.includes(value));
const StringEnum = (values, options = {}) => typebox_1.Type.Unsafe(Object.assign(Object.assign({}, options), { [typebox_1.Kind]: 'StringEnum', type: 'string', enum: values }));
exports.StringEnum = StringEnum;
typebox_1.TypeRegistry.Set('NumberEnum', (schema, value) => schema.enum.includes(value));
const NumberEnum = (values, options = {}) => typebox_1.Type.Unsafe(Object.assign(Object.assign({}, options), { [typebox_1.Kind]: 'NumberEnum', type: 'number', enum: values }));
exports.NumberEnum = NumberEnum;
/**
 *
 */
exports.UniqueIdSchema = typebox_1.Type.String({
    title: 'UniqueId',
    description: i18n_fake_js_1.i18n.t('api.UniqueId.description'),
    /**
     * 128 bits of data encoded as 22 characters of the following alphabet :\n0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_.!~*'()
     * example: "zYnh13HWV76_G3KyE-cAyg"
     * @note This is very loose definition. Basically we're accepting any
     *       non-empty string for now.
     */
    minLength: 1,
});
function makeUniqueIdSchema(description) {
    return typebox_1.Type.String(Object.assign(Object.assign({}, exports.UniqueIdSchema), { description: `${i18n_fake_js_1.i18n.t('api.UniqueId.description')} ${description}` }));
}
exports.makeUniqueIdSchema = makeUniqueIdSchema;
exports.UniqueIdValidator = compiler_1.TypeCompiler.Compile(exports.UniqueIdSchema);
exports.LinkedinRequestUrlSchema = typebox_1.Type.String({
    title: 'LinkedinRequestUrl',
    description: 'An url pointing to some Linkedin API feature',
    pattern: `^https://www.linkedin.com/.*$`,
});
exports.LinkedinRequestUrlValidator = compiler_1.TypeCompiler.Compile(exports.LinkedinRequestUrlSchema);
