"use strict";
/**
 * @todo Find a way to share these definitions with focus-front/core.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHashedAccessToken = exports.isAccessToken = exports.ACCESS_TOKEN_SEPARATOR = exports.isBase64 = exports.isHttpUrl = exports.isTzid = exports.isHourMinuteTime = exports.isUnixTimeMs = exports.isUTCDateTimeMs = void 0;
/**
 *
 */
function isUTCDateTimeMs(value) {
    if (typeof value !== "string") {
        return false;
    }
    const parsed = new Date(value);
    if (Number.isNaN(parsed.getTime())) {
        return false;
    }
    return value === parsed.toISOString();
}
exports.isUTCDateTimeMs = isUTCDateTimeMs;
/**
 *
 */
function isUnixTimeMs(value) {
    if (typeof value !== "number") {
        return false;
    }
    const parsed = new Date(value);
    const time = parsed.getTime();
    if (Number.isNaN(time)) {
        return false;
    }
    return value === time;
}
exports.isUnixTimeMs = isUnixTimeMs;
/**
 *
 */
function isHourMinuteTime(value) {
    if (typeof value !== "string")
        return false;
    const parsed = value.split(":");
    if (parsed.length !== 2)
        return false;
    for (let i = 0; i < parsed.length; i++) {
        const parseNumber = Number(parsed[i]);
        if (isNaN(parseNumber) ||
            Math.sign(parseNumber) === -1 ||
            parsed[i].length !== 2 ||
            parsed[i] > (i === 0 ? "23" : "59"))
            return false;
    }
    return true;
}
exports.isHourMinuteTime = isHourMinuteTime;
const dtfCache = {};
/**
 *
 */
function isTzid(tzid) {
    if (typeof tzid !== "string")
        return false;
    if (!dtfCache[tzid]) {
        try {
            Intl.DateTimeFormat(undefined, { timeZone: tzid });
            dtfCache[tzid] = true;
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    return true;
}
exports.isTzid = isTzid;
/**
 *
 */
function isHttpUrl(url) {
    if (typeof url !== "string")
        return false;
    try {
        const parsed = new URL(url);
        return parsed.protocol === "http:" || parsed.protocol === "https:";
    }
    catch (error) {
        return false;
    }
}
exports.isHttpUrl = isHttpUrl;
const NOT_BASE64_CHAR_REGEX = /[^A-Za-z0-9+/=]/;
/**
 *
 */
function isBase64(s) {
    const length = s.length;
    if (length % 4 !== 0 || NOT_BASE64_CHAR_REGEX.test(s)) {
        return false;
    }
    const firstPaddingChar = s.indexOf("=");
    return (firstPaddingChar === -1 ||
        firstPaddingChar === length - 1 ||
        (firstPaddingChar === length - 2 && s[length - 1] === "="));
}
exports.isBase64 = isBase64;
/**
 *
 */
exports.ACCESS_TOKEN_SEPARATOR = ".";
/**
 *
 */
function isAccessToken(s) {
    const [prefix, secret] = s.split(exports.ACCESS_TOKEN_SEPARATOR);
    return (typeof prefix === "string" &&
        typeof secret === "string" &&
        isBase64(prefix) &&
        isBase64(secret));
}
exports.isAccessToken = isAccessToken;
/**
 *
 */
function isHashedAccessToken(s) {
    const [prefix, hashedSecret] = s.split(exports.ACCESS_TOKEN_SEPARATOR);
    return (typeof prefix === "string" &&
        typeof hashedSecret === "string" &&
        isBase64(prefix) &&
        isBase64(hashedSecret));
}
exports.isHashedAccessToken = isHashedAccessToken;
