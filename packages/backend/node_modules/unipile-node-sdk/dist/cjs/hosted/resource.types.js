"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHostedAuthToken = exports.isSupportedHostedAuthProvider = exports.hostedAuthSupportedAccountTypes = exports.SecretHostedAuthTokenSchema = exports.DisplayableHostedAuthTokenSchema = exports.HostedAuthTokenSchema = exports.HostedAuthTokenReconnectSchema = exports.HostedAuthTokenCreateSchema = exports.HostedAuthTokenBaseSchema = exports.HostedAuthProviderSchema = exports.HostedAuthTokenMessagingProvidersSchema = exports.HostedAuthTokenMailingProvidersSchema = exports.HostedAuthTokenAllProvidersSchema = void 0;
const typebox_1 = require("@sinclair/typebox");
const common_types_js_1 = require("../common/common.types.js");
const date_types_js_1 = require("../common/date.types.js");
const url_types_js_1 = require("../common/url.types.js");
const user_types_js_1 = require("../users/user.types.js");
const ressource_types_js_1 = require("../accounts/ressource.types.js");
const node_crypto_1 = require("node:crypto");
const accounts_create_types_js_1 = require("../accounts/accounts-create.types.js");
/** */
exports.HostedAuthTokenAllProvidersSchema = typebox_1.Type.Literal("*", {
    title: "Any provider",
    description: "Data type: string",
});
exports.HostedAuthTokenMailingProvidersSchema = typebox_1.Type.Literal("*:MAILING", {
    title: "Any mailing provider",
    description: "Data type: string",
});
exports.HostedAuthTokenMessagingProvidersSchema = typebox_1.Type.Literal("*:MESSAGING", {
    title: "Any messaging provider",
    description: "Data type: string",
});
exports.HostedAuthProviderSchema = typebox_1.Type.Union([
    typebox_1.Type.Literal("LINKEDIN"),
    typebox_1.Type.Literal("WHATSAPP"),
    typebox_1.Type.Literal("MESSENGER"),
    typebox_1.Type.Literal("INSTAGRAM"),
    typebox_1.Type.Literal("MAIL"),
    typebox_1.Type.Literal("TELEGRAM"),
    typebox_1.Type.Literal("MICROSOFT"),
    typebox_1.Type.Literal("TWITTER"),
    typebox_1.Type.Literal("MAIL"),
    typebox_1.Type.Literal("GOOGLE"),
    typebox_1.Type.Literal("OUTLOOK"),
]);
/** */
exports.HostedAuthTokenBaseSchema = typebox_1.Type.Object({
    id: common_types_js_1.UniqueIdSchema,
    prefix: typebox_1.Type.String(),
    hashedToken: typebox_1.Type.String(),
    username: user_types_js_1.EmailSchema,
    issuedAt: date_types_js_1.UTCDateTimeMsSchema,
    expiresOn: date_types_js_1.UTCDateTimeMsSchema,
    name: typebox_1.Type.Optional(typebox_1.Type.String({
        minLength: 1,
        description: "This field will be sent back to you in the notify_url to help match the added account with your user.",
    })),
    success_redirect_url: typebox_1.Type.Optional((0, url_types_js_1.HttpUrlType)({
        description: "A url where you might want to redirect the user in case of a successful authentication.",
    })),
    failure_redirect_url: typebox_1.Type.Optional((0, url_types_js_1.HttpUrlType)({
        description: "A url where you might want to redirect the user in case of a failed authentication.",
    })),
    notify_url: typebox_1.Type.Optional((0, url_types_js_1.HttpUrlType)({
        description: "A url where you can be notified about events related to the authentication process.",
    })),
    disabled_features: typebox_1.Type.Optional(typebox_1.Type.Array((0, common_types_js_1.StringEnum)([
        "linkedin_recruiter",
        "linkedin_sales_navigator",
        "linkedin_organizations_mailboxes",
    ]), {
        description: "An array of features that should be disabled in this account. Accepted values : linkedin_recruiter | linkedin_sales_navigator | linkedin_organizations_mailboxes.",
    })),
    api_url: (0, url_types_js_1.HttpUrlType)({
        description: "The url of your Unipile server  : https://{subdomain}.unipile.com:{port}",
    }),
    sync_limit: typebox_1.Type.Optional(typebox_1.Type.Object({
        MAILING: typebox_1.Type.Optional(accounts_create_types_js_1.MailSyncLimitValueSchema),
        MESSAGING: typebox_1.Type.Optional(typebox_1.Type.Object({
            chats: typebox_1.Type.Optional(accounts_create_types_js_1.MessagingSyncLimitValueSchema),
            messages: typebox_1.Type.Optional(accounts_create_types_js_1.MessagingSyncLimitValueSchema),
        }, {
            description: "Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
        })),
    })),
    //   sync_limit: Type.Optional(
    //     Type.Object({
    //       chats: Type.Optional(Type.Number()),
    //       messages: Type.Optional(Type.Number()),
    //     })
    //   ),
});
/** */
exports.HostedAuthTokenCreateSchema = typebox_1.Type.Composite([
    exports.HostedAuthTokenBaseSchema,
    typebox_1.Type.Object({
        type: typebox_1.Type.Literal("create", {
            description: "A litteral value to choose between a connection or a reconnection.",
        }),
        providers: typebox_1.Type.Union([
            exports.HostedAuthTokenAllProvidersSchema,
            exports.HostedAuthTokenMailingProvidersSchema,
            exports.HostedAuthTokenMessagingProvidersSchema,
            typebox_1.Type.Array(ressource_types_js_1.AvailableAccountProvider, {
                title: "One or more providers",
                description: "Data type: Array of strings. Accepted values: LINKEDIN | WHATSAPP | INSTAGRAM | MESSENGER | TELEGRAM | GOOGLE | OUTLOOK | MAIL | TWITTER",
            }),
        ], {
            description: "The providers for whom you want to propose to connect an account.",
        }),
    }),
]);
/** */
exports.HostedAuthTokenReconnectSchema = typebox_1.Type.Composite([
    exports.HostedAuthTokenBaseSchema,
    typebox_1.Type.Object({
        type: typebox_1.Type.Literal("reconnect", {
            description: "A litteral value to choose between a connection or a reconnection.",
        }),
        reconnect_account: typebox_1.Type.String({
            description: "The id of the account to reconnect.",
            minLength: 1,
        }),
        account_type: exports.HostedAuthProviderSchema,
    }),
]);
/** */
exports.HostedAuthTokenSchema = typebox_1.Type.Union([
    exports.HostedAuthTokenCreateSchema,
    exports.HostedAuthTokenReconnectSchema,
]);
/** */
exports.DisplayableHostedAuthTokenSchema = typebox_1.Type.Omit(typebox_1.Type.Union([
    exports.HostedAuthTokenCreateSchema,
    typebox_1.Type.Composite([
        exports.HostedAuthTokenReconnectSchema,
        typebox_1.Type.Object({
            account_type: exports.HostedAuthProviderSchema,
        }),
    ]),
]), ["hashedToken"]);
/**
 * Shown once on creation, not stored, not retrievable.
 */
exports.SecretHostedAuthTokenSchema = typebox_1.Type.Omit(typebox_1.Type.Union([
    typebox_1.Type.Composite([
        exports.HostedAuthTokenCreateSchema,
        typebox_1.Type.Object({
            token: typebox_1.Type.String(),
        }),
    ]),
    typebox_1.Type.Composite([
        exports.HostedAuthTokenReconnectSchema,
        typebox_1.Type.Object({
            token: typebox_1.Type.String(),
        }),
    ]),
]), ["hashedToken"]);
/** */
exports.hostedAuthSupportedAccountTypes = new Set([
    "LINKEDIN",
    "WHATSAPP",
    "INSTAGRAM",
    "MESSENGER",
    "MAIL",
    "OUTLOOK",
    "GOOGLE_OAUTH",
]);
/** */
function isSupportedHostedAuthProvider(accountType) {
    return exports.hostedAuthSupportedAccountTypes.has(accountType);
}
exports.isSupportedHostedAuthProvider = isSupportedHostedAuthProvider;
/** */
function createHostedAuthToken(content) {
    if (!(content.issuedAt <= content.expiresOn)) {
        return "INVALID_DATES";
    }
    if (content.username === "") {
        return "EMPTY_NAME";
    }
    return Object.assign(Object.assign({}, content), { 
        /**
         * id is not used with current in-memory usage of HostedAuthToken.
         * We keep the original HostedAuthToken shape until the situation has
         * settled down.
         */
        // id: createUuidFrom(content.prefix, HOSTEDAUTHTOKEN_NAMESPACE),
        id: (0, node_crypto_1.randomBytes)(16).toString("base64") });
}
exports.createHostedAuthToken = createHostedAuthToken;
