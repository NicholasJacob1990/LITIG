"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountConnectApiResponseValidator = exports.AccountConnectApiResponseSchema = exports.AccountCreateCheckpointApiResponseSchema = exports.AccountCreatedApiResponseSchema = exports.AccountCreateBodyValidator = exports.AccountCreateBodySchema = exports.AccountCreateTwitterBodySchema = exports.AccountCreateMessengerBodySchema = exports.AccountCreateInstagramBodySchema = exports.AccountCreateTelegramBodySchema = exports.AccountCreateWhatsappBodySchema = exports.AccountCreateLinkedinBodySchema = exports.AccountCreateLinkedinCookieBodySchema = exports.AccountCreateLinkedinBasicBodySchema = exports.isLinkedinUsernameValid = exports.AccountCreateLinkedinBaseBodySchema = exports.AccountCreateOutlookBodySchema = exports.AccountCreateGoogleOauthBodySchema = exports.AccountCreateImapMailBodySchema = exports.AccountCreateBaseSchema = exports.MessagingSyncLimitSchema = exports.MessagingSyncLimitValueSchema = exports.MailSyncLimitSchema = exports.MailSyncLimitValueSchema = exports.AccountCreateProxyParamsSchema = void 0;
const typebox_1 = require("@sinclair/typebox");
const compiler_1 = require("@sinclair/typebox/compiler");
const common_types_js_1 = require("../common/common.types.js");
const date_types_js_1 = require("../common/date.types.js");
const user_types_js_1 = require("../users/user.types.js");
// --------------------------------------------------------------------------
// REQUEST
// --------------------------------------------------------------------------
/**
 *
 */
exports.AccountCreateProxyParamsSchema = typebox_1.Type.Object({
    protocol: typebox_1.Type.Optional((0, common_types_js_1.StringEnum)(['https', 'http', 'socks5'])),
    port: typebox_1.Type.Number(),
    host: typebox_1.Type.String(),
    username: typebox_1.Type.Optional(typebox_1.Type.String({
        description: 'Optional username for proxy’s authentication.',
    })),
    password: typebox_1.Type.Optional(typebox_1.Type.String({
        description: 'Optional password for proxy’s authentication.',
    })),
});
exports.MailSyncLimitValueSchema = typebox_1.Type.Union([
    // UTCDateTimeMsSchema, // @todo Maybe later.
    typebox_1.Type.Literal('NO_HISTORY_SYNC'),
    // Type.Literal("NO_LIMIT"),
]);
exports.MailSyncLimitSchema = typebox_1.Type.Object({
    sync_limit: typebox_1.Type.Optional(exports.MailSyncLimitValueSchema),
});
exports.MessagingSyncLimitValueSchema = typebox_1.Type.Union([
    date_types_js_1.UTCDateTimeMsSchema,
    typebox_1.Type.Number({
        minimum: 0,
        description: 'The quantity of data that should be synced from data history. 0 will not sync history.',
    }),
], {
    description: 'Either a UTC Datetime to start sync from, or a quantity of data.',
});
exports.MessagingSyncLimitSchema = typebox_1.Type.Object({
    sync_limit: typebox_1.Type.Optional(typebox_1.Type.Object({
        chats: typebox_1.Type.Optional(exports.MessagingSyncLimitValueSchema),
        messages: typebox_1.Type.Optional(exports.MessagingSyncLimitValueSchema),
    }, {
        description: 'Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.',
    })),
});
/**
 *
 */
exports.AccountCreateBaseSchema = typebox_1.Type.Object({
    disabled_features: typebox_1.Type.Optional(typebox_1.Type.Array((0, common_types_js_1.StringEnum)(['linkedin_recruiter', 'linkedin_sales_navigator', 'linkedin_organizations_mailboxes']), {
        description: 'An array of features that should be disabled for this account.',
    })),
});
/**
 * Imap Mail body schema
 */
exports.AccountCreateImapMailBodySchema = typebox_1.Type.Composite([
    exports.AccountCreateBaseSchema,
    exports.MailSyncLimitSchema,
    typebox_1.Type.Object({
        provider: typebox_1.Type.Union([typebox_1.Type.Literal('MAIL')]),
        imap_user: user_types_js_1.EmailSchema,
        smtp_user: user_types_js_1.EmailSchema,
        imap_password: typebox_1.Type.String(),
        smtp_password: typebox_1.Type.String(),
        imap_host: typebox_1.Type.String(),
        imap_port: typebox_1.Type.Number(),
        smtp_host: typebox_1.Type.String(),
        smtp_port: typebox_1.Type.Number(),
        imap_encryption: typebox_1.Type.String(),
    }),
], { title: 'IMAP' });
/**
 * Google oauth body schema
 */
exports.AccountCreateGoogleOauthBodySchema = typebox_1.Type.Composite([
    exports.AccountCreateBaseSchema,
    exports.MailSyncLimitSchema,
    typebox_1.Type.Object({
        provider: typebox_1.Type.Literal('GOOGLE_OAUTH'),
        refresh_token: typebox_1.Type.String(),
        access_token: typebox_1.Type.String(),
    }),
], { title: 'Gmail' });
/**
 * Outlook oauth body schema
 */
exports.AccountCreateOutlookBodySchema = typebox_1.Type.Composite([
    exports.AccountCreateBaseSchema,
    exports.MailSyncLimitSchema,
    typebox_1.Type.Object({
        provider: typebox_1.Type.Literal('OUTLOOK'),
        refresh_token: typebox_1.Type.String(),
        access_token: typebox_1.Type.String(),
        username: typebox_1.Type.String(),
        id: typebox_1.Type.String(),
    }),
], { title: 'Outlook' });
/**
 * Linkedin body schema
 */
exports.AccountCreateLinkedinBaseBodySchema = typebox_1.Type.Composite([
    exports.AccountCreateBaseSchema,
    exports.MessagingSyncLimitSchema,
    typebox_1.Type.Object({
        provider: typebox_1.Type.Literal('LINKEDIN'),
        proxy: typebox_1.Type.Optional(exports.AccountCreateProxyParamsSchema),
        user_agent: typebox_1.Type.Optional(typebox_1.Type.String({
            description: `If encountering disconnection issues, enter the exact user agent of the browser on which the account has been connected. You can easily retrieve it in the browser's console with this command : "console.log(navigator.userAgent)"`,
        })),
        recruiter_contract_id: typebox_1.Type.Optional(typebox_1.Type.String({
            description: 'The contract that should be used with Linkedin Recruiter.',
        })),
    }),
]);
const isLinkedinUsernameValid = (value) => /(^\S+@\S+$)|(^\+?(\d|\s)+$)/gm.test(value);
exports.isLinkedinUsernameValid = isLinkedinUsernameValid;
exports.AccountCreateLinkedinBasicBodySchema = typebox_1.Type.Composite([
    exports.AccountCreateLinkedinBaseBodySchema,
    typebox_1.Type.Object({
        username: typebox_1.Type.String({
            description: 'Should be either an email address or a phone number.',
        }),
        password: typebox_1.Type.String(),
    }),
], {
    title: 'Basic authentication',
    description: 'Authenticate using your username and password',
});
exports.AccountCreateLinkedinCookieBodySchema = typebox_1.Type.Composite([
    exports.AccountCreateLinkedinBaseBodySchema,
    typebox_1.Type.Object({
        access_token: typebox_1.Type.String({
            description: 'Linkedin access token, which is to be found under the key "li_at".',
        }),
        premium_token: typebox_1.Type.Optional(typebox_1.Type.String({
            description: 'Linkedin Recruiter/Sales Navigator authentication cookie, which is to be found under the key "li_a". It should be used if you need to be logged to an existing session. It not provided, a new session will be started.',
        })),
    }),
], {
    title: 'Cookie authentication',
    description: 'Authenticate using cookies',
});
exports.AccountCreateLinkedinBodySchema = typebox_1.Type.Union([
    exports.AccountCreateLinkedinBasicBodySchema,
    exports.AccountCreateLinkedinCookieBodySchema,
]);
/**
 * Whatsapp body schema
 */
exports.AccountCreateWhatsappBodySchema = typebox_1.Type.Composite([exports.AccountCreateBaseSchema, typebox_1.Type.Object({ provider: typebox_1.Type.Literal('WHATSAPP') })], {
    title: 'Whatsapp',
    description: 'You just need to set the provider parameter to "WHATSAPP" to begin the authentication. In response, you will receive a string which needs to be converted to a QR code and scanned to complete the authentication.',
});
exports.AccountCreateTelegramBodySchema = typebox_1.Type.Composite([exports.AccountCreateBaseSchema, typebox_1.Type.Object({ provider: typebox_1.Type.Literal('TELEGRAM') })], {
    title: 'Telegram',
    description: 'You just need to set the provider parameter to "TELEGRAM" to begin the authentication. In response, you will receive a string which needs to be converted to a QR code and scanned to complete the authentication.',
});
exports.AccountCreateInstagramBodySchema = typebox_1.Type.Composite([
    exports.AccountCreateBaseSchema,
    exports.MessagingSyncLimitSchema,
    typebox_1.Type.Object({
        provider: typebox_1.Type.Literal('INSTAGRAM'),
        username: typebox_1.Type.String({
            description: 'Your Instagram username.',
        }),
        password: typebox_1.Type.String({
            description: 'Your Instagram password.',
        }),
        user_agent: typebox_1.Type.Optional(typebox_1.Type.String({
            description: `If encountering disconnection issues, enter the exact user agent of the browser on which the account has been connected. You can easily retrieve it in the browser's console with this command : "console.log(navigator.userAgent)"`,
        })),
    }),
], { title: 'Instagram' });
exports.AccountCreateMessengerBodySchema = typebox_1.Type.Composite([
    exports.AccountCreateBaseSchema,
    exports.MessagingSyncLimitSchema,
    typebox_1.Type.Object({
        provider: typebox_1.Type.Literal('MESSENGER'),
        username: typebox_1.Type.String(),
        password: typebox_1.Type.String(),
    }),
], { title: 'Messenger' });
exports.AccountCreateTwitterBodySchema = typebox_1.Type.Composite([
    exports.AccountCreateBaseSchema,
    typebox_1.Type.Object({
        provider: typebox_1.Type.Literal('TWITTER'),
        username: typebox_1.Type.String(),
        email: user_types_js_1.EmailSchema,
        password: typebox_1.Type.String(),
    }),
], { title: 'Twitter' });
/**
 *
 */
exports.AccountCreateBodySchema = typebox_1.Type.Union([
    exports.AccountCreateLinkedinBodySchema,
    exports.AccountCreateWhatsappBodySchema,
    exports.AccountCreateInstagramBodySchema,
    exports.AccountCreateMessengerBodySchema,
    exports.AccountCreateImapMailBodySchema,
    exports.AccountCreateGoogleOauthBodySchema,
    exports.AccountCreateTelegramBodySchema,
    exports.AccountCreateOutlookBodySchema,
    exports.AccountCreateTwitterBodySchema,
    // AccountCreateImapMailBodySchema,
    // AccountCreateMicrosoftMailBodySchema,
]);
/**
 *
 */
exports.AccountCreateBodyValidator = compiler_1.TypeCompiler.Compile(exports.AccountCreateBodySchema);
// /**
//  *
//  */
// export const getAccountCreateBodyOpenApiSchema = makeOpenApiSchemaGetter(
//   AccountCreateBodySchema
// );
// --------------------------------------------------------------------------
// RESPONSE
// --------------------------------------------------------------------------
/**
 * Global schema for every account when final creation step is done
 */
exports.AccountCreatedApiResponseSchema = typebox_1.Type.Object({
    object: typebox_1.Type.Literal('AccountCreated'),
    account_id: common_types_js_1.UniqueIdSchema,
});
// /**
//  *
//  */
// export const getAccountCreatedResponseOpenApiSchema = makeOpenApiSchemaGetter(
//   AccountCreatedApiResponseSchema
// );
/**
 *
 */
exports.AccountCreateCheckpointApiResponseSchema = typebox_1.Type.Object({
    object: typebox_1.Type.Literal('Checkpoint'),
    account_id: common_types_js_1.UniqueIdSchema,
    checkpoint: typebox_1.Type.Union([
        typebox_1.Type.Object({
            type: typebox_1.Type.Literal('QRCODE'),
            qrcode: typebox_1.Type.String({
                description: 'This string needs to be converted into a QR code and scanned to complete the authentication.',
            }),
        }, {
            title: 'QR code',
        }),
        typebox_1.Type.Object({
            type: typebox_1.Type.Literal('2FA', {
                description: 'You need to provide a code to solve this checkpoint. You can use the route "Solve a code checkpoint" to do it.',
            }),
            source: typebox_1.Type.Optional(typebox_1.Type.Union([
                typebox_1.Type.Literal('SMS', {
                    description: 'The code has been sent via SMS.',
                }),
                typebox_1.Type.Literal('APP', {
                    description: 'The code is available on your authentication app.',
                }),
            ])),
        }, {
            title: '2FA',
        }),
        typebox_1.Type.Object({
            type: typebox_1.Type.Literal('OTP', {
                description: 'You need to provide a code to solve this checkpoint. You can use the route "Solve a code checkpoint" to do it.',
            }),
        }, {
            title: 'OTP',
        }),
        typebox_1.Type.Object({
            type: typebox_1.Type.Literal('PHONE_REGISTER', {
                description: 'You need to provide a mobile phone number to receive a 2FA code. You can use the route "Solve a code checkpoint" to do it.',
            }),
        }, {
            title: 'PHONE_REGISTER',
        }),
        typebox_1.Type.Object({
            type: typebox_1.Type.Literal('IN_APP_VALIDATION', {
                description: 'You need to perform an action in the provider’s app to solve this checkpoint.',
            }),
        }, { title: 'IN_APP_VALIDATION' }),
        typebox_1.Type.Object({
            type: typebox_1.Type.Literal('CAPTCHA', {
                description: 'The captcha could not be solved by our automatized services.',
            }),
            public_key: typebox_1.Type.Optional(typebox_1.Type.String({
                description: 'The public key of the provider for on-device resolution (Arkose Labs captcha).',
            })),
            data: typebox_1.Type.Optional(typebox_1.Type.String({
                description: 'The data payload of the provider for on-device resolution (Arkose Labs captcha).',
            })),
        }, { title: 'CAPTCHA' }),
        typebox_1.Type.Object({
            type: typebox_1.Type.Literal('CONTRACT_CHOOSER', {
                description: 'Gives options to pick the contract you need Recruiter to be connected to.',
            }),
            contract_options: typebox_1.Type.Array(typebox_1.Type.Object({ id: typebox_1.Type.String(), name: typebox_1.Type.String() })),
        }, { title: 'CONTRACT_CHOOSER' }),
    ]),
});
// /**
//  *
//  */
// export const getAccountCreateCheckpointResponseOpenApiSchema =
//   makeOpenApiSchemaGetter(AccountCreateCheckpointApiResponseSchema);
/**  */
exports.AccountConnectApiResponseSchema = typebox_1.Type.Union([
    exports.AccountCreatedApiResponseSchema,
    exports.AccountCreateCheckpointApiResponseSchema,
]);
/**  */
exports.AccountConnectApiResponseValidator = compiler_1.TypeCompiler.Compile(exports.AccountConnectApiResponseSchema);
