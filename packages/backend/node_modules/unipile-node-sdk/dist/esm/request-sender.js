"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestSender = void 0;
const index_js_1 = require("./errors/index.js");
class RequestSender {
    constructor(state) {
        this.clientState = state;
        this.defaultHeaders = {
            'X-API-KEY': this.clientState.token,
            accept: 'application/json',
        };
    }
    send(input) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            const options = (_a = input.options) !== null && _a !== void 0 ? _a : {};
            const url = this.buildUrl({
                protocol: this.clientState.protocol,
                domain: this.clientState.domain,
                apiVersion: this.clientState.apiVersion,
                path: input.path,
                parameters: (_b = input.parameters) !== null && _b !== void 0 ? _b : {},
            });
            // console.log('url', url, {
            //   protocol: this.clientState.protocol,
            //   domain: this.clientState.domain,
            //   apiVersion: this.clientState.apiVersion,
            //   path: input.path,
            //   parameters: input.parameters ?? {},
            // });
            let parsedBody;
            if (input.body !== undefined && ((_c = input.headers) === null || _c === void 0 ? void 0 : _c['Content-Type']) === 'application/json')
                parsedBody = JSON.stringify(input.body);
            else
                parsedBody = input.body || undefined;
            const response = yield fetch(url, {
                method: input.method,
                headers: Object.assign({}, this.defaultHeaders, (_d = input.headers) !== null && _d !== void 0 ? _d : {}),
                body: parsedBody,
            });
            if ((_e = options.logRequestResult) !== null && _e !== void 0 ? _e : this.clientState.logRequestResult)
                console.log(`RequestSender: ${response.status}, ${response.statusText} - ${input.method} ${url}`);
            const bodyType = response.headers.get('content-type');
            let body;
            if (bodyType === null || bodyType === void 0 ? void 0 : bodyType.includes('application/json')) {
                body = yield response.json();
            }
            else {
                body = yield response.blob();
            }
            if ((_f = options.logRequestPayload) !== null && _f !== void 0 ? _f : this.clientState.logRequestPayload) {
                console.log(body);
                //   console.log(JSON.stringify({ bodyType, body }, null, 2));
            }
            const successfulRequest = response.status >= 200 && response.status < 300;
            const validationActivated = (_g = options.validateRequestPayload) !== null && _g !== void 0 ? _g : this.clientState.validateRequestPayload;
            const validationLevel = (_h = options.validateRequestPayloadLevel) !== null && _h !== void 0 ? _h : this.clientState.validateRequestPayloadLevel;
            if (successfulRequest && validationActivated) {
                if (input.validator === undefined)
                    throw new index_js_1.ValidatorMissingError();
                return this.validate(body, input.validator, validationLevel);
            }
            else if (successfulRequest && !validationActivated) {
                return body;
            }
            else {
                throw new index_js_1.UnsuccessfulRequestError(body);
            }
        });
    }
    buildUrl(UrlObject) {
        const { protocol, domain, apiVersion, path, parameters } = UrlObject;
        const formattedApiVersion = '/' + apiVersion;
        const formattedPath = path.map((subFolder) => '/' + subFolder).join('');
        let formattedParameters;
        if (Object.keys(parameters).length === 0)
            formattedParameters = '';
        else {
            /**
             * @todo Check if we need to something about + signs ?
             *       cf. https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#preserving_plus_signs
             */
            formattedParameters = '?' + new URLSearchParams(parameters).toString();
        }
        const url = protocol + '://' + domain + '/api' + formattedApiVersion + formattedPath + formattedParameters;
        return url;
    }
    validate(value, validator, level) {
        if (!validator.Check(value)) {
            switch (level) {
                case 'warn': {
                    const errors = Array.from(validator.Errors(value));
                    const firstError = JSON.stringify(errors[0], null, 2);
                    const errorSampleLength = 1000;
                    console.warn(`WARNING : The response didn't fully match the one expected by the SDK.
Make sure the SDK is up to date. If the SDK is up to date and you still get the warning, please contact our support.

Here is the first error :
            
${firstError.substring(0, errorSampleLength)}${firstError.length > errorSampleLength ? '\n... (continued in .body)' : ''}`, errors);
                    return value;
                }
                case 'error':
                    throw new index_js_1.InvalidResponseTypeError(validator.Errors(value), value);
            }
        }
        return value;
    }
}
exports.RequestSender = RequestSender;
