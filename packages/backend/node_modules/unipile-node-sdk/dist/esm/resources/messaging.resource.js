"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessagingResource = void 0;
const index_js_1 = require("../index.js");
const chats_list_types_js_1 = require("../messaging/chats/chats-list.types.js");
const chat_types_js_1 = require("../messaging/chats/chat.types.js");
const message_list_types_js_1 = require("../messaging/messages/message-list.types.js");
const message_send_types_js_1 = require("../messaging/messages/message-send.types.js");
const chat_start_types_js_1 = require("../messaging/chats/chat-start.types.js");
const chat_attendees_list_types_js_1 = require("../messaging/chat-attendees/chat-attendees-list.types.js");
const message_types_js_1 = require("../messaging/messages/message.types.js");
const chat_attendee_types_js_1 = require("../messaging/chat-attendees/chat-attendee.types.js");
const chat_patch_types_js_1 = require("../messaging/chats/chat-patch.types.js");
class MessagingResource {
    constructor(client) {
        this.client = client;
    }
    getAllChats(input = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { before, after, limit, account_type, account_id, cursor, unread } = input;
            const parameters = Object.assign({}, options === null || options === void 0 ? void 0 : options.extra_params);
            if (before)
                parameters.before = before;
            if (after)
                parameters.after = after;
            if (limit)
                parameters.limit = String(limit);
            if (account_type)
                parameters.account_type = account_type;
            if (account_id)
                parameters.account_id = account_id;
            if (cursor)
                parameters.cursor = cursor;
            if (unread !== undefined)
                parameters.unread = unread ? 'true' : 'false';
            return yield this.client.request.send({
                path: ['chats'],
                method: 'GET',
                options,
                parameters,
                validator: chats_list_types_js_1.ChatListApiResponseValidator,
            });
        });
    }
    getChat(chatId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.request.send(Object.assign(Object.assign({ path: ['chats', chatId], method: 'GET', options }, ((options === null || options === void 0 ? void 0 : options.extra_params) && { parameters: options.extra_params })), { validator: chat_types_js_1.ChatResponseValidator }));
        });
    }
    getAllMessagesFromChat(input, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { chat_id, sender_id, before, after, limit, cursor } = input;
            const parameters = Object.assign({}, options === null || options === void 0 ? void 0 : options.extra_params);
            if (sender_id)
                parameters.sender_id = sender_id;
            if (before)
                parameters.before = before;
            if (after)
                parameters.after = after;
            if (limit)
                parameters.limit = String(limit);
            if (cursor)
                parameters.cursor = cursor;
            return yield this.client.request.send({
                path: ['chats', chat_id, 'messages'],
                method: 'GET',
                parameters,
                options,
                validator: message_list_types_js_1.MessageListApiResponseValidator,
            });
        });
    }
    sendMessage(input, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { chat_id, text, thread_id, attachments } = input;
            const body = new FormData();
            body.append('text', text);
            if (thread_id)
                body.append('thread_id', thread_id);
            if (attachments !== undefined) {
                for (const [filename, buffer] of attachments) {
                    body.append('attachments', new Blob([buffer]), filename);
                }
            }
            if (options === null || options === void 0 ? void 0 : options.extra_params) {
                Object.entries(options.extra_params).forEach(([k, v]) => {
                    if (!body.has(k)) {
                        body.append(k, v);
                    }
                });
            }
            return yield this.client.request.send({
                path: ['chats', chat_id, 'messages'],
                method: 'POST',
                body,
                headers: {},
                options,
                validator: message_send_types_js_1.MessageSentResponseValidator,
            });
        });
    }
    startNewChat(input, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { account_id, text, subject, options: input_options, attendees_ids, attachments } = input;
            const body = new FormData();
            body.append('account_id', account_id);
            body.append('text', text);
            for (const id of attendees_ids)
                body.append('attendees_ids', id);
            if (subject)
                body.append('subject', subject);
            if (input_options) {
                if (input_options.linkedin) {
                    if (input_options.linkedin.api !== undefined) {
                        body.append('linkedin[api]', input_options.linkedin.api);
                    }
                    if ((0, index_js_1.isLinkedinClassicPostNewChatInputOptions)(input_options.linkedin)) {
                        if (input_options.linkedin.inmail !== undefined) {
                            body.append('linkedin[inmail]', input_options.linkedin.inmail ? 'true' : 'false');
                        }
                    }
                    if ((0, index_js_1.isLinkedinRecruiterPostNewChatInputOptions)(input_options.linkedin)) {
                        if (input_options.linkedin.signature !== undefined) {
                            body.append('linkedin[signature]', input_options.linkedin.signature);
                        }
                        if (input_options.linkedin.hiring_project_id !== undefined) {
                            body.append('linkedin[hiring_project_id]', input_options.linkedin.hiring_project_id);
                        }
                        if (input_options.linkedin.email_address !== undefined) {
                            body.append('linkedin[email_address]', input_options.linkedin.email_address);
                        }
                    }
                }
            }
            if (attachments !== undefined) {
                for (const [filename, buffer] of attachments) {
                    body.append('attachments', new Blob([buffer]), filename);
                }
            }
            if (options === null || options === void 0 ? void 0 : options.extra_params) {
                Object.entries(options.extra_params).forEach(([k, v]) => {
                    if (!body.has(k)) {
                        body.append(k, v);
                    }
                });
            }
            return yield this.client.request.send({
                path: ['chats'],
                method: 'POST',
                body,
                headers: {},
                options,
                validator: chat_start_types_js_1.ChatStartedApiResponseValidator,
            });
        });
    }
    getAllAttendeesFromChat(chat_id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.request.send(Object.assign(Object.assign({ path: ['chats', chat_id, 'attendees'], method: 'GET', options }, ((options === null || options === void 0 ? void 0 : options.extra_params) && { parameters: options.extra_params })), { validator: chat_attendees_list_types_js_1.ChatAttendeeByChatListApiResponseValidator }));
        });
    }
    getMessage(message_id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.request.send(Object.assign(Object.assign({ path: ['messages', message_id], method: 'GET', options }, ((options === null || options === void 0 ? void 0 : options.extra_params) && { parameters: options.extra_params })), { validator: message_types_js_1.MessageResponseValidator }));
        });
    }
    getAllMessages(input = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { before, after, limit, sender_id, account_id, cursor } = input;
            const parameters = Object.assign({}, options === null || options === void 0 ? void 0 : options.extra_params);
            if (before)
                parameters.before = before;
            if (after)
                parameters.after = after;
            if (limit)
                parameters.limit = String(limit);
            if (sender_id)
                parameters.sender_id = sender_id;
            if (account_id)
                parameters.account_id = account_id;
            if (cursor)
                parameters.cursor = cursor;
            return yield this.client.request.send({
                path: ['messages'],
                method: 'GET',
                parameters,
                options,
                validator: message_list_types_js_1.MessageListApiResponseValidator,
            });
        });
    }
    getAllMessagesFromAttendee(input, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { attendee_id, cursor, before, after, limit } = input;
            const parameters = Object.assign({}, options === null || options === void 0 ? void 0 : options.extra_params);
            if (cursor)
                parameters.cursor = cursor;
            if (before)
                parameters.before = before;
            if (after)
                parameters.after = after;
            if (limit)
                parameters.limit = String(limit);
            return yield this.client.request.send({
                path: ['chat_attendees', attendee_id, 'messages'],
                method: 'GET',
                parameters,
                options,
                validator: message_list_types_js_1.MessageListApiResponseValidator,
            });
        });
    }
    getAllChatsFromAttendee(input, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { attendee_id, cursor, before, after, limit, account_id } = input;
            const parameters = Object.assign({}, options === null || options === void 0 ? void 0 : options.extra_params);
            if (cursor)
                parameters.cursor = cursor;
            if (before)
                parameters.before = before;
            if (after)
                parameters.after = after;
            if (limit)
                parameters.limit = String(limit);
            if (account_id)
                parameters.account_id = account_id;
            return yield this.client.request.send({
                path: ['chat_attendees', attendee_id, 'chats'],
                method: 'GET',
                parameters,
                options,
                validator: chats_list_types_js_1.ChatListApiResponseValidator,
            });
        });
    }
    getMessageAttachment(input, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { message_id, attachment_id } = input;
            return yield this.client.request.send(Object.assign(Object.assign({ path: ['messages', message_id, 'attachments', attachment_id], method: 'GET', options }, ((options === null || options === void 0 ? void 0 : options.extra_params) && { parameters: options.extra_params })), { validator: index_js_1.untypedYetValidator }));
        });
    }
    getAllAttendees(input = {}, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { cursor, limit, account_id } = input;
            const parameters = Object.assign({}, options === null || options === void 0 ? void 0 : options.extra_params);
            if (cursor)
                parameters.cursor = cursor;
            if (limit)
                parameters.limit = String(limit);
            if (account_id)
                parameters.account_id = account_id;
            return yield this.client.request.send({
                path: ['chat_attendees'],
                method: 'GET',
                parameters,
                options,
                validator: chat_attendees_list_types_js_1.ChatAttendeeListApiResponseValidator,
            });
        });
    }
    getAttendee(attendee_id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.request.send(Object.assign(Object.assign({ path: ['chat_attendees', attendee_id], method: 'GET', options }, ((options === null || options === void 0 ? void 0 : options.extra_params) && { parameters: options.extra_params })), { validator: chat_attendee_types_js_1.ChatAttendeeResponseValidator }));
        });
    }
    setChatStatus(input, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { chat_id, action, value } = input;
            const body = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.extra_params), { action,
                value });
            return yield this.client.request.send({
                path: ['chats', chat_id],
                method: 'PATCH',
                body,
                headers: {
                    'Content-Type': 'application/json',
                },
                options,
                validator: chat_patch_types_js_1.ChatPatchedApiResponseValidator,
            });
        });
    }
}
exports.MessagingResource = MessagingResource;
