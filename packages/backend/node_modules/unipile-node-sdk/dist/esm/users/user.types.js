"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserValidator = exports.UserSchema = exports.UserReferralCodeValidator = exports.UserReferralCodeSchema = exports.UserIdValidator = exports.UserIdSchema = exports.UserNameValidator = exports.UserNameSchema = exports.EmailValidator = exports.EmailSchema = void 0;
const typebox_1 = require("@sinclair/typebox");
const compiler_1 = require("@sinclair/typebox/compiler");
const system_1 = require("@sinclair/typebox/system");
/**
 * @note Keep sub-schemas separated to be able to validate only the parts you're
 *       interested in.
 */
/**
 * @note This is a very loose definition of an 'usual' email shape.
 *       Yet it will reject some technically valid email addresses,
 *       e.g. email without top-level domains.
 *
 *       The idea is to pre-filter some input to get an UnverifiedEmail,
 *       then send a verification email and once verification is complete,
 *       graduate it to a VerifiedEmail.
 */
const LOOSE_EMAIL_SHAPE_REGEX = /^\S+@\S+\.\S+$/;
system_1.TypeSystem.Format("emailLike", (s) => LOOSE_EMAIL_SHAPE_REGEX.test(s));
exports.EmailSchema = typebox_1.Type.String({ format: "emailLike" });
exports.EmailValidator = compiler_1.TypeCompiler.Compile(exports.EmailSchema);
/**
 *
 */
exports.UserNameSchema = typebox_1.Type.Object({
    username: exports.EmailSchema,
});
exports.UserNameValidator = compiler_1.TypeCompiler.Compile(exports.UserNameSchema);
/**
 *
 */
exports.UserIdSchema = typebox_1.Type.Object({
    id: typebox_1.Type.Number(),
});
exports.UserIdValidator = compiler_1.TypeCompiler.Compile(exports.UserIdSchema);
/**
 *
 */
exports.UserReferralCodeSchema = typebox_1.Type.Object({
    id: typebox_1.Type.String(),
});
exports.UserReferralCodeValidator = compiler_1.TypeCompiler.Compile(exports.UserReferralCodeSchema);
/**
 * @todo Populate as needed.
 */
/** */
exports.UserSchema = typebox_1.Type.Composite([
    exports.UserNameSchema,
    exports.UserIdSchema,
    exports.UserReferralCodeSchema,
]);
exports.UserValidator = compiler_1.TypeCompiler.Compile(exports.UserSchema);
// /** */
// export const UserIntersectSchema = Type.Intersect([
//   UserNameSchema,
//   UserIdSchema,
// ]);
// export type UserIntersect = Static<typeof UserIntersectSchema>;
// export const UserIntersectValidator = TypeCompiler.Compile(UserIntersectSchema);
// export const UserSchema = Type.Object({
//   username: EmailSchema,
//   id: Type.Number(),
// });
// export type User = Static<typeof UserSchema>;
// export const UserValidator = TypeCompiler.Compile(UserSchema);
// console.log(
//   EmailValidator.Code(),
//   UserNameValidator.Code(),
//   UserIdValidator.Code(),
//   UserValidator.Code(),
//   EmailValidator.Check('azdazda@yahoo.fr'),
//   //   UserCompositeValidator.Code(),
//   //   UserIntersectValidator.Code(),
// );
