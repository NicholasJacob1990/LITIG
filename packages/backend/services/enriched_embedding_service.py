#!/usr/bin/env python3
"""
Servi√ßo de Embeddings Enriquecidos: CV + KPIs + Performance (1024D)

Combina dados textuais (CV, especializa√ß√£o) com m√©tricas num√©ricas (KPIs, performance)
em um "super-documento" que √© processado pelos modelos V2 especializados.

Caracter√≠sticas:
- Integra√ß√£o hol√≠stica de texto + dados
- Templates estruturados para diferentes contextos
- Versionamento para itera√ß√£o e A/B testing
- M√©tricas de qualidade e performance
"""
import logging
import json
import time
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime

# Importar servi√ßo V2 base
try:
    from .embedding_service_v2 import legal_embedding_service_v2
    EMBEDDING_V2_AVAILABLE = True
except ImportError:
    logger.warning("EmbeddingServiceV2 n√£o dispon√≠vel")
    EMBEDDING_V2_AVAILABLE = False

logger = logging.getLogger(__name__)


@dataclass
class LawyerProfile:
    """Perfil estruturado do advogado para gera√ß√£o de embeddings enriquecidos."""
    id: str
    nome: str
    cv_text: str
    tags_expertise: List[str]
    kpi: Dict[str, Any]
    kpi_subarea: Dict[str, Any]
    total_cases: int
    publications: List[str]
    education: str
    professional_experience: str
    city: str
    state: str
    interaction_score: Optional[float] = None
    
    def __post_init__(self):
        """Normaliza e valida dados do perfil."""
        # Garantir que campos obrigat√≥rios n√£o sejam None
        self.cv_text = self.cv_text or ""
        self.tags_expertise = self.tags_expertise or []
        self.kpi = self.kpi or {}
        self.kpi_subarea = self.kpi_subarea or {}
        self.publications = self.publications or []
        self.education = self.education or ""
        self.professional_experience = self.professional_experience or ""


class EnrichedEmbeddingService:
    """
    Servi√ßo para gerar embeddings enriquecidos que combinam:
    1. Dados textuais (CV, especializa√ß√£o, publica√ß√µes)
    2. M√©tricas de performance (KPIs, taxa de sucesso)
    3. Contexto profissional (experi√™ncia, educa√ß√£o)
    4. Dados de engajamento (interaction_score)
    """
    
    def __init__(self):
        self.version = "v1.0"
        
        if not EMBEDDING_V2_AVAILABLE:
            raise RuntimeError("EmbeddingServiceV2 √© obrigat√≥rio para embeddings enriquecidos")
        
        # Templates para diferentes tipos de enriquecimento
        self.templates = {
            "complete": self._template_complete,
            "performance_focused": self._template_performance_focused,
            "expertise_focused": self._template_expertise_focused,
            "balanced": self._template_balanced
        }
        
        logger.info(f"üß† EnrichedEmbeddingService inicializado - vers√£o {self.version}")

    async def generate_enriched_embedding(
        self,
        lawyer_profile: LawyerProfile,
        template_type: str = "balanced",
        force_provider: Optional[str] = None
    ) -> Tuple[List[float], str, Dict[str, Any]]:
        """
        Gera embedding enriquecido combinando texto + m√©tricas.
        
        Args:
            lawyer_profile: Perfil estruturado do advogado
            template_type: Tipo de template ("complete", "performance_focused", etc.)
            force_provider: For√ßar provedor espec√≠fico ("openai", "voyage", "arctic")
            
        Returns:
            Tuple[embedding_vector, provider_name, metadata]
        """
        start_time = time.time()
        
        ab_test_group = "default_strategy"
        provider_to_force = force_provider

        # --- L√ìGICA DO A/B TESTE ---
        # Se um provedor n√£o for for√ßado externamente, aplicamos nosso teste A/B.
        if not provider_to_force:
            # Dividir os advogados em dois grupos com base no √∫ltimo caractere do ID.
            # Grupo 'voyage_primary': 50% dos casos. For√ßa o uso do Voyage Law-2.
            # Grupo 'openai_primary': 50% dos casos. Usa a cascata padr√£o (que come√ßa com OpenAI).
            last_char = lawyer_profile.id[-1]
            if last_char in '56789abcdef':
                ab_test_group = "voyage_primary"
                provider_to_force = "voyage"
            else:
                ab_test_group = "openai_primary"
                # N√£o for√ßamos provedor, usamos a estrat√©gia padr√£o.

        try:
            # 1. Construir super-documento usando template
            if template_type not in self.templates:
                raise ValueError(f"Template '{template_type}' n√£o encontrado")
            
            enriched_text = self.templates[template_type](lawyer_profile)
            
            # 2. Gerar embedding usando V2, aplicando a l√≥gica do A/B Test
            embedding, provider = await legal_embedding_service_v2.generate_legal_embedding(
                enriched_text,
                "lawyer_cv_enriched",
                force_provider=provider_to_force
            )
            
            # 3. Calcular m√©tricas
            generation_time = time.time() - start_time
            
            metadata = {
                "version": self.version,
                "template_type": template_type,
                "provider": provider,
                "ab_test_group": ab_test_group, # Adiciona rastreabilidade do teste A/B
                "generation_time": generation_time,
                "document_length": len(enriched_text),
                "kpi_fields_used": list(lawyer_profile.kpi.keys()),
                "expertise_areas": len(lawyer_profile.tags_expertise),
                "publications_count": len(lawyer_profile.publications),
                "generated_at": datetime.now().isoformat()
            }
            
            logger.info(f"‚úÖ Embedding enriquecido gerado: {len(embedding)}D via {provider}")
            logger.debug(f"üìä Metadata: {metadata}")
            
            return embedding, provider, metadata
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao gerar embedding enriquecido: {e}")
            raise

    def _template_complete(self, profile: LawyerProfile) -> str:
        """Template completo com todos os dados dispon√≠veis."""
        
        # Extrair KPIs principais
        kpi = profile.kpi
        success_rate = kpi.get('taxa_sucesso', kpi.get('success_rate', 0))
        avg_rating = kpi.get('avaliacao_media', kpi.get('avg_rating', 0))
        cases_30d = kpi.get('casos_30d', kpi.get('cases_30d', 0))
        capacity = kpi.get('capacidade_mensal', kpi.get('monthly_capacity', 0))
        
        # Construir se√ß√µes do documento
        sections = []
        
        # Se√ß√£o 1: Identifica√ß√£o e Localiza√ß√£o
        sections.append(f"[PERFIL PROFISSIONAL]\nAdvogado(a): {profile.nome}")
        if profile.city and profile.state:
            sections.append(f"Localiza√ß√£o: {profile.city}, {profile.state}")
        
        # Se√ß√£o 2: Especializa√ß√£o e Expertise
        if profile.tags_expertise:
            expertise_text = ", ".join(profile.tags_expertise)
            sections.append(f"[ESPECIALIZA√á√ïES]\n√Åreas de atua√ß√£o: {expertise_text}")
        
        # Se√ß√£o 3: Dados de Performance (KPIs)
        performance_lines = []
        if success_rate > 0:
            performance_lines.append(f"Taxa de sucesso: {success_rate:.1%}")
        if avg_rating > 0:
            performance_lines.append(f"Avalia√ß√£o m√©dia dos clientes: {avg_rating:.1f}/5.0")
        if cases_30d > 0:
            performance_lines.append(f"Casos ativos (√∫ltimos 30 dias): {cases_30d}")
        if capacity > 0:
            performance_lines.append(f"Capacidade mensal: {capacity} casos")
        if profile.total_cases > 0:
            performance_lines.append(f"Total de casos hist√≥ricos: {profile.total_cases}")
        
        if performance_lines:
            sections.append(f"[M√âTRICAS DE PERFORMANCE]\n" + "\n".join(performance_lines))
        
        # Se√ß√£o 4: Performance por Sub√°rea
        if profile.kpi_subarea:
            subarea_lines = []
            for subarea, data in profile.kpi_subarea.items():
                if isinstance(data, dict):
                    subarea_success = data.get('success_rate', data.get('taxa_sucesso', 0))
                    subarea_cases = data.get('total_cases', data.get('total_casos', 0))
                    if subarea_success > 0 or subarea_cases > 0:
                        subarea_lines.append(f"{subarea}: {subarea_success:.1%} sucesso, {subarea_cases} casos")
            
            if subarea_lines:
                sections.append(f"[PERFORMANCE POR √ÅREA]\n" + "\n".join(subarea_lines[:5]))  # Top 5
        
        # NOVO: Se√ß√£o 5: Dados de APIs Externas
        external_data = self._extract_external_api_data(profile)
        if external_data:
            sections.append(f"[DADOS ESPECIALIZADOS]\n{external_data}")
        
        # Se√ß√£o 6: Qualifica√ß√µes e Educa√ß√£o
        if profile.education:
            try:
                education_data = json.loads(profile.education) if isinstance(profile.education, str) else profile.education
                if isinstance(education_data, list) and education_data:
                    education_text = "; ".join([str(ed) for ed in education_data[:3]])  # Top 3
                    sections.append(f"[FORMA√á√ÉO ACAD√äMICA]\n{education_text}")
            except (json.JSONDecodeError, TypeError):
                if profile.education.strip():
                    sections.append(f"[FORMA√á√ÉO ACAD√äMICA]\n{profile.education[:200]}")
        
        # Se√ß√£o 7: Experi√™ncia Profissional
        if profile.professional_experience:
            try:
                exp_data = json.loads(profile.professional_experience) if isinstance(profile.professional_experience, str) else profile.professional_experience
                if isinstance(exp_data, list) and exp_data:
                    exp_text = "; ".join([str(exp) for exp in exp_data[:3]])  # Top 3
                    sections.append(f"[EXPERI√äNCIA PROFISSIONAL]\n{exp_text}")
            except (json.JSONDecodeError, TypeError):
                if profile.professional_experience.strip():
                    sections.append(f"[EXPERI√äNCIA PROFISSIONAL]\n{profile.professional_experience[:200]}")
        
        # Se√ß√£o 8: Publica√ß√µes e Produ√ß√£o Acad√™mica
        if profile.publications:
            pub_count = len(profile.publications)
            pub_sample = "; ".join(profile.publications[:3])  # Top 3
            sections.append(f"[PRODU√á√ÉO ACAD√äMICA]\n{pub_count} publica√ß√µes: {pub_sample}")
        
        # Se√ß√£o 9: Engajamento na Plataforma
        if profile.interaction_score is not None:
            engagement_level = "alto" if profile.interaction_score > 0.7 else "m√©dio" if profile.interaction_score > 0.4 else "baixo"
            sections.append(f"[ENGAJAMENTO]\nN√≠vel de engajamento na plataforma: {engagement_level}")
        
        # Se√ß√£o 10: Descri√ß√£o do CV (se dispon√≠vel)
        if profile.cv_text.strip():
            cv_excerpt = profile.cv_text[:300]  # Primeiros 300 caracteres
            sections.append(f"[RESUMO DO CURR√çCULO]\n{cv_excerpt}")
        
        # Se√ß√£o 11: Contexto de Qualidade
        quality_indicators = []
        if success_rate > 0.8:
            quality_indicators.append("alta taxa de sucesso")
        if avg_rating > 4.0:
            quality_indicators.append("excelente avalia√ß√£o dos clientes")
        if cases_30d > 10:
            quality_indicators.append("alta atividade recente")
        if len(profile.publications) > 5:
            quality_indicators.append("produ√ß√£o acad√™mica significativa")
        
        if quality_indicators:
            sections.append(f"[DESTAQUES]\nAdvogado(a) com {', '.join(quality_indicators)}")
        
        return "\n\n".join(sections)

    def _template_performance_focused(self, profile: LawyerProfile) -> str:
        """Template focado em performance e m√©tricas."""
        
        kpi = profile.kpi
        success_rate = kpi.get('taxa_sucesso', kpi.get('success_rate', 0))
        avg_rating = kpi.get('avaliacao_media', kpi.get('avg_rating', 0))
        cases_30d = kpi.get('casos_30d', kpi.get('cases_30d', 0))
        
        sections = []
        
        # Performance como foco principal
        performance_desc = f"Advogado(a) {profile.nome} com "
        perf_metrics = []
        
        if success_rate > 0:
            perf_metrics.append(f"taxa de sucesso de {success_rate:.1%}")
        if avg_rating > 0:
            perf_metrics.append(f"avalia√ß√£o m√©dia de {avg_rating:.1f}/5.0")
        if cases_30d > 0:
            perf_metrics.append(f"{cases_30d} casos ativos")
        
        if perf_metrics:
            performance_desc += ", ".join(perf_metrics)
        
        sections.append(f"[PERFORMANCE DESTACADA]\n{performance_desc}")
        
        # Especializa√ß√£o com contexto de performance
        if profile.tags_expertise:
            expertise_text = ", ".join(profile.tags_expertise)
            sections.append(f"[ESPECIALIZA√á√ÉO COMPROVADA]\nEspecialista em {expertise_text}")
        
        # KPIs por sub√°rea (apenas as melhores)
        if profile.kpi_subarea:
            best_subareas = []
            for subarea, data in profile.kpi_subarea.items():
                if isinstance(data, dict):
                    subarea_success = data.get('success_rate', data.get('taxa_sucesso', 0))
                    if subarea_success > 0.7:  # Apenas √°reas com alta performance
                        best_subareas.append(f"{subarea} ({subarea_success:.1%})")
            
            if best_subareas:
                sections.append(f"[√ÅREAS DE ALTA PERFORMANCE]\n{'; '.join(best_subareas[:3])}")
        
        # Resumo do CV com foco em resultados
        if profile.cv_text:
            sections.append(f"[EXPERI√äNCIA COMPROVADA]\n{profile.cv_text[:200]}")
        
        return "\n\n".join(sections)

    def _template_expertise_focused(self, profile: LawyerProfile) -> str:
        """Template focado em especializa√ß√£o e conhecimento t√©cnico."""
        
        sections = []
        
        # Especializa√ß√£o como foco principal
        if profile.tags_expertise:
            expertise_text = ", ".join(profile.tags_expertise)
            sections.append(f"[ESPECIALIZA√á√ÉO JUR√çDICA]\nAdvogado(a) {profile.nome}, especialista em {expertise_text}")
        
        # Forma√ß√£o e qualifica√ß√µes
        if profile.education:
            sections.append(f"[QUALIFICA√á√ïES ACAD√äMICAS]\n{profile.education[:300]}")
        
        # Produ√ß√£o acad√™mica como diferencial
        if profile.publications:
            pub_count = len(profile.publications)
            sections.append(f"[PRODU√á√ÉO ACAD√äMICA]\n{pub_count} publica√ß√µes relevantes na √°rea jur√≠dica")
        
        # Experi√™ncia espec√≠fica
        if profile.professional_experience:
            sections.append(f"[EXPERI√äNCIA ESPECIALIZADA]\n{profile.professional_experience[:300]}")
        
        # Performance como valida√ß√£o da expertise
        kpi = profile.kpi
        success_rate = kpi.get('taxa_sucesso', kpi.get('success_rate', 0))
        if success_rate > 0:
            sections.append(f"[EXPERTISE COMPROVADA]\nTaxa de sucesso de {success_rate:.1%} valida a especializa√ß√£o")
        
        # CV completo
        if profile.cv_text:
            sections.append(f"[PERFIL PROFISSIONAL]\n{profile.cv_text[:400]}")
        
        return "\n\n".join(sections)

    def _template_balanced(self, profile: LawyerProfile) -> str:
        """Template balanceado combinando todos os aspectos principais."""
        
        sections = []
        
        # Introdu√ß√£o completa
        intro = f"Advogado(a) {profile.nome}"
        if profile.tags_expertise:
            intro += f", especializado(a) em {', '.join(profile.tags_expertise[:3])}"
        sections.append(f"[PERFIL PROFISSIONAL]\n{intro}")
        
        # Performance equilibrada
        kpi = profile.kpi
        success_rate = kpi.get('taxa_sucesso', kpi.get('success_rate', 0))
        avg_rating = kpi.get('avaliacao_media', kpi.get('avg_rating', 0))
        
        if success_rate > 0 or avg_rating > 0:
            perf_text = []
            if success_rate > 0:
                perf_text.append(f"taxa de sucesso: {success_rate:.1%}")
            if avg_rating > 0:
                perf_text.append(f"avalia√ß√£o: {avg_rating:.1f}/5.0")
            sections.append(f"[PERFORMANCE]\n{', '.join(perf_text)}")
        
        # Qualifica√ß√µes resumidas
        if profile.education or profile.publications:
            qual_parts = []
            if profile.education:
                qual_parts.append("forma√ß√£o acad√™mica s√≥lida")
            if profile.publications:
                qual_parts.append(f"{len(profile.publications)} publica√ß√µes")
            sections.append(f"[QUALIFICA√á√ïES]\n{', '.join(qual_parts)}")
        
        # Experi√™ncia resumida
        if profile.total_cases > 0:
            sections.append(f"[EXPERI√äNCIA]\n{profile.total_cases} casos tratados")
        
        # Resumo do CV
        if profile.cv_text:
            sections.append(f"[RESUMO]\n{profile.cv_text[:250]}")
        
        return "\n\n".join(sections)

    def _extract_external_api_data(self, profile: LawyerProfile) -> str:
        """
        Extrai e formata dados de APIs externas para inclus√£o no embedding.
        
        Busca por:
        - Dados do Escavador (processos, taxa real de sucesso, ESPECIALIZA√á√ïES REAIS)
        - Dados do JusBrasil (volume por √°rea)
        - An√°lise Perplexity (soft skills, sentimento)
        - Hybrid stats (dados unificados)
        - Curr√≠culo Lattes via Escavador (expertise acad√™mica)
        """
        external_lines = []
        
        # 1. Dados h√≠bridos (Escavador + JusBrasil)
        if hasattr(profile, 'hybrid_stats') and profile.hybrid_stats:
            hybrid = profile.hybrid_stats
            if hasattr(hybrid, 'real_success_rate') and hybrid.real_success_rate > 0:
                external_lines.append(f"Taxa de sucesso verificada (Escavador): {hybrid.real_success_rate:.1%}")
            
            if hasattr(hybrid, 'total_verified_cases') and hybrid.total_verified_cases > 0:
                external_lines.append(f"Casos verificados em tribunais: {hybrid.total_verified_cases}")
            
            if hasattr(hybrid, 'specialization_score') and hybrid.specialization_score > 0:
                external_lines.append(f"Score de especializa√ß√£o: {hybrid.specialization_score:.2f}")
        
        # 2. Dados espec√≠ficos do Escavador
        escavador_data = profile.kpi.get('escavador_data')
        if escavador_data:
            if escavador_data.get('victories', 0) > 0:
                victories = escavador_data['victories']
                total = escavador_data.get('total_cases', victories)
                external_lines.append(f"Vit√≥rias documentadas: {victories}/{total} casos")
            
            if escavador_data.get('avg_case_value', 0) > 0:
                avg_value = escavador_data['avg_case_value']
                external_lines.append(f"Valor m√©dio por caso: R$ {avg_value:,.2f}")
            
            # üÜï ESPECIALIZA√á√ÉO BASEADA EM HIST√ìRICO REAL DE PROCESSOS
            if escavador_data.get('area_distribution'):
                area_dist = escavador_data['area_distribution']
                # Ordenar por quantidade de casos (especializa√ß√£o real)
                areas_sorted = sorted(area_dist.items(), key=lambda x: x[1], reverse=True)
                
                if areas_sorted:
                    top_areas = []
                    for area, casos in areas_sorted[:3]:  # Top 3 √°reas
                        percentage = (casos / sum(area_dist.values())) * 100
                        if percentage >= 10:  # S√≥ √°reas com pelo menos 10% do hist√≥rico
                            top_areas.append(f"{area} ({casos} casos, {percentage:.0f}%)")
                    
                    if top_areas:
                        external_lines.append(f"Especializa√ß√£o comprovada por hist√≥rico processual: {'; '.join(top_areas)}")
            
            # Performance espec√≠fica por √°rea jur√≠dica
            if escavador_data.get('area_performance'):
                area_perf = escavador_data['area_performance']
                best_areas = []
                for area, perf in area_perf.items():
                    if isinstance(perf, dict):
                        success_rate = perf.get('success_rate', 0)
                        case_count = perf.get('case_count', 0)
                        if success_rate > 0.8 and case_count >= 5:  # Alta performance com volume
                            best_areas.append(f"{area} ({success_rate:.1%} de sucesso)")
                
                if best_areas:
                    external_lines.append(f"√Åreas de alta performance comprovada: {'; '.join(best_areas[:3])}")
        
        # 3. Curr√≠culo Lattes via Escavador (expertise acad√™mica)
        curriculo_escavador = profile.kpi.get('curriculo_escavador')
        if curriculo_escavador:
            anos_exp = curriculo_escavador.get('anos_experiencia', 0)
            if anos_exp > 0:
                external_lines.append(f"Experi√™ncia comprovada: {anos_exp} anos de atua√ß√£o")
            
            pos_graduacoes = curriculo_escavador.get('pos_graduacoes', [])
            if pos_graduacoes:
                titulos = [pq.get('titulo', '') for pq in pos_graduacoes[:3]]  # Top 3
                if titulos:
                    external_lines.append(f"T√≠tulos acad√™micos: {'; '.join(titulos)}")
            
            publicacoes = curriculo_escavador.get('num_publicacoes', 0)
            if publicacoes > 0:
                external_lines.append(f"Produ√ß√£o acad√™mica: {publicacoes} publica√ß√µes indexadas")
            
            areas_lattes = curriculo_escavador.get('areas_de_atuacao', '')
            if areas_lattes:
                external_lines.append(f"√Åreas de atua√ß√£o acad√™mica: {areas_lattes[:100]}")
            
            # Projetos de pesquisa
            projetos = curriculo_escavador.get('projetos_pesquisa', [])
            if projetos:
                external_lines.append(f"Projetos de pesquisa: {len(projetos)} projetos registrados")
        
        # 4. An√°lise de soft skills (Perplexity)
        soft_skills_data = profile.kpi.get('soft_skills_analysis')
        if soft_skills_data:
            sentiment = soft_skills_data.get('sentiment_score', 0)
            if sentiment > 0:
                sentiment_level = "excelente" if sentiment > 0.8 else "boa" if sentiment > 0.6 else "adequada"
                external_lines.append(f"An√°lise de comunica√ß√£o: {sentiment_level} ({sentiment:.1%})")
            
            if soft_skills_data.get('professionalism_score', 0) > 0:
                prof_score = soft_skills_data['professionalism_score']
                external_lines.append(f"Score de profissionalismo: {prof_score:.2f}/5.0")
        
        # 5. Dados de volume por √°rea (JusBrasil)
        area_volume = profile.kpi.get('area_volume_data')
        if area_volume:
            top_areas = []
            for area, count in sorted(area_volume.items(), key=lambda x: x[1], reverse=True)[:3]:
                if count > 5:  # S√≥ √°reas com volume significativo
                    top_areas.append(f"{area} ({count} casos)")
            
            if top_areas:
                external_lines.append(f"Volume hist√≥rico por √°rea (JusBrasil): {'; '.join(top_areas)}")
        
        # 6. An√°lise de especializa√ß√£o h√≠brida (combinando fontes)
        all_specializations = []
        
        # Combinar especializa√ß√µes do CV declarado
        if profile.tags_expertise:
            all_specializations.extend([(area, 'declarado') for area in profile.tags_expertise])
        
        # Combinar especializa√ß√µes do hist√≥rico real (Escavador)
        if escavador_data and escavador_data.get('area_distribution'):
            area_dist = escavador_data['area_distribution']
            total_cases = sum(area_dist.values())
            for area, casos in area_dist.items():
                if casos >= 5 and (casos/total_cases) >= 0.15:  # M√≠nimo 15% dos casos
                    all_specializations.append((area, 'comprovado'))
        
        # Analisar consist√™ncia entre declarado vs comprovado
        if all_specializations:
            declarado = [area for area, tipo in all_specializations if tipo == 'declarado']
            comprovado = [area for area, tipo in all_specializations if tipo == 'comprovado']
            
            # Verificar alinhamento
            alinhados = set(declarado) & set(comprovado)
            if alinhados:
                external_lines.append(f"Especializa√ß√£o validada: {', '.join(alinhados)} (declarado + comprovado)")
            
            # Especializa√ß√£o emergente (s√≥ no hist√≥rico)
            emergente = set(comprovado) - set(declarado)
            if emergente:
                external_lines.append(f"Especializa√ß√£o emergente: {', '.join(emergente)} (n√£o declarado mas comprovado)")
        
        # 7. Transpar√™ncia dos dados
        transparency = profile.kpi.get('data_transparency')
        if transparency:
            confidence = transparency.get('confidence_score', 0)
            if confidence > 0.7:
                external_lines.append(f"Dados verificados com alta confiabilidade ({confidence:.1%})")
            
            source = transparency.get('primary_source', '')
            if source:
                external_lines.append(f"Fonte prim√°ria de dados: {source}")
        
        # 8. Score de maturidade profissional (combinando tudo)
        if curriculo_escavador and escavador_data:
            anos_exp = curriculo_escavador.get('anos_experiencia', 0)
            total_casos = escavador_data.get('total_cases', 0)
            publicacoes = curriculo_escavador.get('num_publicacoes', 0)
            
            # Calcular score de maturidade (0-100)
            maturity_score = 0
            if anos_exp > 0:
                maturity_score += min(30, anos_exp * 2)  # M√°ximo 30 pontos por experi√™ncia
            if total_casos > 0:
                maturity_score += min(40, total_casos)  # M√°ximo 40 pontos por casos
            if publicacoes > 0:
                maturity_score += min(30, publicacoes * 3)  # M√°ximo 30 pontos por publica√ß√µes
            
            if maturity_score > 50:
                maturity_level = "senior" if maturity_score > 75 else "pleno" if maturity_score > 60 else "j√∫nior"
                external_lines.append(f"Perfil de maturidade profissional: {maturity_level} (score: {maturity_score:.0f}/100)")
        
        return "\n".join(external_lines) if external_lines else ""

    async def generate_batch_enriched_embeddings(
        self,
        lawyer_profiles: List[LawyerProfile],
        template_type: str = "balanced",
        batch_size: int = 10
    ) -> List[Tuple[str, List[float], str, Dict[str, Any]]]:
        """
        Gera embeddings enriquecidos em batch para m√∫ltiplos advogados.
        
        Returns:
            Lista de tuplas (lawyer_id, embedding, provider, metadata)
        """
        results = []
        
        for i in range(0, len(lawyer_profiles), batch_size):
            batch = lawyer_profiles[i:i + batch_size]
            
            # Processar batch em paralelo
            import asyncio
            tasks = [
                self.generate_enriched_embedding(profile, template_type)
                for profile in batch
            ]
            
            batch_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for profile, result in zip(batch, batch_results):
                if isinstance(result, Exception):
                    logger.error(f"Erro ao processar {profile.id}: {result}")
                    continue
                
                embedding, provider, metadata = result
                results.append((profile.id, embedding, provider, metadata))
        
        return results

    def get_template_info(self) -> Dict[str, str]:
        """Retorna informa√ß√µes sobre os templates dispon√≠veis."""
        return {
            "complete": "Template completo com todos os dados (m√°xima informa√ß√£o)",
            "performance_focused": "Foco em KPIs e m√©tricas de performance",
            "expertise_focused": "Foco em especializa√ß√£o e conhecimento t√©cnico",
            "balanced": "Template balanceado para uso geral"
        }


# Factory function
def create_enriched_embedding_service() -> EnrichedEmbeddingService:
    """Factory function para criar inst√¢ncia do servi√ßo."""
    return EnrichedEmbeddingService()


# Inst√¢ncia global
enriched_embedding_service = create_enriched_embedding_service()


# Fun√ß√£o de conveni√™ncia
async def generate_enriched_embedding(
    lawyer_profile: LawyerProfile,
    template_type: str = "balanced"
) -> Tuple[List[float], str, Dict[str, Any]]:
    """Fun√ß√£o de conveni√™ncia para gerar embedding enriquecido."""
    return await enriched_embedding_service.generate_enriched_embedding(
        lawyer_profile, template_type
    )